\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER Interactive Prolog Education Runtime}
\subtitle{Testbericht}
\author{Paul Brinkmeier, Lukas Brocke, Jannik Koch, Aaron Maier, Christian Oder}
\date{}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{dirtree}
\usepackage{pgfplots}
\usepackage{pgfgantt}
\usepackage{pifont}
\usepackage{multicol}
\hypersetup{
	pdftitle={Testbericht},
}

\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\lstset{basicstyle=\ttfamily,breaklines=true}

% Don't strech across whole page
\raggedbottom

% Start new page with each section
\usepackage{sectsty}
\sectionfont{\clearpage}

\def\qa{\hfill\textbf{QA}}
\def\impl{\hfill\textbf{IM}}

\begin{document}
\pagenumbering{roman}
\maketitle

\tableofcontents

\section{Einleitung}
\pagenumbering{arabic}
\setcounter{page}{1}

In der Testphase wird VIPER durch weitere Unittests sowie die im Pflichtenheft vorgestellten Testfall-Szenarien getestet. Außerdem wird das Programm in Hinblick auf Nutzbarkeit und Codequalität geprüft und überarbeitet.

Die Unittests werden mit dem Framework JUnit \footnote{\url{https://junit.org/}} geschrieben. Die durch diese Tests erreichte Abdeckung wird mit JaCoCo \footnote{\url{https://www.eclemma.org/jacoco/}} überprüft. Das Ziel ist eine Abdeckung nahe 100\% für das Controller Paket sowie alle Model Pakete. Mittels JAssertSwing \footnote{\url{https://joel-costigliola.github.io/assertj/assertj-swing.html}} wird auch das View Paket von VIPER so weit wie möglich automatisch getestet.

Für einheitlich formattieren Quelltext wird Checkstyle \footnote{\url{https://checkstyle.org/}} verwendet. Die Konfiguration stammt von der Vorlesung Programmieren und wird um einige striktere Regeln erweitert. Die Werkzeuge FindBugs \footnote{\url{http://findbugs.sourceforge.net/}} und PMD \footnote{\url{https://pmd.github.io/}} werden eingesetzt, um den Quelltext zur Übersetzungszeit auf Fehler und schlechten Programmierstil zu überprüfen.

Um VIPER auf Nutzbarkeit zu prüfen, wird das Programm von außenstehenden Personen mit und ohne Vorkenntnisse in Prolog verwendet. Dabei entstehende Meinungen und beobachtete Reaktionen gehen in die Überarbeitung des Programms mit ein.

Für die Verwaltung von gefundenen Fehlern und zu implementierenden Features werden die Issues des GitLab Repositories verwendet. Diese erlauben u.a. Vorlagen, Gewichtungen sowie das Zuweisen von zuständigen Personen. Außerdem werden die genannten Werkzeuge in das Gradle Buildsystem integriert, sodass die im GitLab konfigurierte Continuous Integration das Projekt testen und bauen kann.

\section{Tests}

Die im Folgenden beschriebenen Tests entsprechen allen Tests seit \textbf{Beginn der Implementierung}. Tests, welche erst in der Qualitätssicherung hinzugekommen sind werden entsprechend mit \textbf{QA} markiert, Tests aus der Implementierungsphase mit \textbf{IM}.

\subsection{Unit-Tests}

\subsubsection{Model: AST}
\subsubsection{Model: Parser}
\subsubsection{Model: Interpreter}
\subsubsection{Model: Visualisation}
\subsubsection{View}
\subsubsection{Controller}
\textbf{Anmerkung zum Testen von grafischem User-Input:}\\
Da einige Kommandos User"=Input in Form von Dialogen (Datei"=Auswahldialog und Options"=Dialog) erwartet, wurden in diesen neue Konstruktoren angelegt. Diese sind ausschließlich zum Erstellen einer Testversion der Unit da und bieten den zu nutzenden Dialog als Parameter an. Hierzu wurden Options"=Dialoge (Interface: OptionPane) und Datei"=Auswahldialog (Interface: FileChooser) abstrahiert.

Sowohl für die OptionPane als auch für den FileChooser existieren Implementierungen, welche für den normalen Betrieb genutzt werden und einfach an die entsprechende Java-Dialogklasse delegieren (DefaultOptionPane und DefaultFileChooser). Beim Testen wird stattdessen eine Dummy"=Implementierung übergeben, welche einen vordefinierten Rückgabewert hat und diesen ohne Öffnen eines grafischen Dialogs zurückgibt. Hierzu zählen für die OptionPane die Klassen YesOptionPane, NoOptionPane und CancelOptionPane. Für den FileChooser existiert die Klasse PreselectionFileChooser, welche sich mit einer Datei initialisiert wird und diese bei Aufruf zurückgibt.

Da die Nutzung von Dialogen recht gering und einheitlich ist (ausschließlich ein Typ von Options"= und Datei-Auswahldialogen), wurde dieser Weg als simpler erachtet und von der Nutzung eines Mocking"=Frameworks abgesehen.

Das Testen von Popups (Handbuch, Standardbibliothek und Über) fand wiederum über die AssertJSwing"=Bibliothek statt, über welche die Fenster erhalten und geprüft werden konnten. Dies funktionierte aufgrund der nativen Java-Implementierung auch nach mehreren Versuchen und einigen Tagen nicht mit Dialogen, weswegen die zuvor beschriebene Lösung für diese genutzt wurde. Die Nutzung von AssertJSwing beschränkt sich somit ausschließlich auf Popups.

\textbf{Testklasse: CommandCancelTest, getestete Unit: CommandCancel}
\begin{itemize}
	\item[--] \texttt{cancelTest()}:\impl\\
	Startet die Suche nach einer Lösung und versucht, diese erfolgreich zu unterbrechen.
\end{itemize}

\textbf{Testklasse: CommandExitTest, getestete Unit: CommandExit}
\begin{itemize}
	\item[--] \texttt{saveOnExitTest()}:\qa\\
	Versucht, das Programm mit ungespeicherten Änderungen erfolgreich zu beenden und speichert diese bei Aufruf.
	\item[--] \texttt{doNotSaveChangesTest()}:\qa\\
	Versucht, das Programm mit ungespeicherten Änderungen erfolgreich zu beenden und speichert diese bei Aufruf nicht.
	\item[--] \texttt{cancelTest()}:\qa\\
	Versucht, das Programm mit ungespeicherten Änderungen erfolgreich zu beenden und bricht den Vorgang bei Aufruf zum Speichern ab.
	\item[--] \texttt{nothingUnsavedTest()}:\qa\\
	Versucht, das Programm ohne ungespeicherte Änderungen erfolgreich zu beenden.
\end{itemize}

\textbf{Testklasse: CommandExportImageTest, getestete Unit: CommandExportImage}
\begin{itemize}
	\item[--] \texttt{pngByDialogTest()}:\qa\\
	Versucht, eine Visualisierung erfolgreich als PNG per Dialog zu exportieren.
	\item[--] \texttt{svgByDialogTest()}:\qa\\
	Versucht, eine Visualisierung erfolgreich als SVG per Dialog zu exportieren.
	\item[--] \texttt{nullFileTest()}:\qa\\
	Versucht, eine Visualisierung per Dialog zu exportieren, wenn die ausgewählte Datei null ist. Dies sollte keinen Effekt haben.
	\item[--] \texttt{errorOutputTest()}:\qa\\
	Versucht, erfolgreich einen Fehler über die Ausgaberoutine des Kommandos auszugeben.´
\end{itemize}

\textbf{Testklasse: CommandFinishQueryTest, getestete Unit: CommandFinishQuery}
\begin{itemize}
	\item[--] \texttt{finishQueryTest()}:\qa\\
	Versucht, eine Anfrage erfolgreich bis zum Ende auszuführen und eine Lösung auszulesen.
\end{itemize}

\textbf{Testklasse: CommandFormatTest, getestete Unit: CommandFormat}
\begin{itemize}
	\item[--] \texttt{simpsonsTest()}:\impl\\
	Versucht, das unformatierte Simpsons-Beispiel aus dem Pflichtenheft erfolgreich in die angegebene formatierte Form zu bringen.
	\item[--] \texttt{simpsonsTwiceTest()}:\qa\\
	Versucht, das unformatierte Simpsons-Beispiel aus dem Pflichtenheft zweifach zu formatieren. Dies sollte dasselbe Ergebnis haben wie nach einfachem Formatieren.
	\item[--] \texttt{invalidTest()}:\qa\\
	Versucht, ein Programm zu formatieren, welches nicht erfolgreich geparst werden kann. Dies sollte scheitern.
	\item[--] \texttt{invalidDebugTest()}:\qa\\
	Versucht, ein Programm zu formatieren, welches nicht erfolgreich geparst werden kann. Dies sollte scheitern. Dies geschieht hier im Debug-Modus und sollte entsprechenden Output erzeugen.
	\item[--] \texttt{emptyTest()}:\impl\\
	Versucht, den leeren Editor erfolgreich zu formatieren. Dies sollte keinen Effekt haben.
\end{itemize}

\textbf{Testklasse: CommandNewTest, getestete Unit: CommandNew}
\begin{itemize}
	\item[--] \texttt{getsClearedTest()}:\impl\\
	Versucht, erfolgreich eine neue Datei anzulegen, wenn keine ungespeicherten Änderungen vorhanden sind. Dies sollte den Editor leeren.
	\item[--] \texttt{saveOnExitTest()}:\qa\\
	Versucht, erfolgreich eine neue Datei anzulegen, wenn ungespeicherte Änderungen existieren und versucht weiter, diese zu speichern.
	\item[--] \texttt{doNotSaveOnExitTest()}:\qa\\
	Versucht, erfolgreich eine neue Datei anzulegen, wenn ungespeicherte Änderungen existieren und versucht weiter, das Speichern dieser abzulehnen.
	\item[--] \texttt{cancelSaveOnExitTest()}:\qa\\
	Versucht, erfolgreich eine neue Datei anzulegen, wenn ungespeicherte Änderungen existieren und versucht weiter, das Speichern dieser abzubrechen.
\end{itemize}

\textbf{Testklasse: CommandNextSolutionTest, getestete Unit: CommandNextSolution}
\begin{itemize}
	\item[--] \texttt{nextSolutionTest()}:\qa\\
	Versucht, eine Abfrage erfolgreich bis zur nächsten Lösung zu interpretieren und prüft die gefundene Lösung.
\end{itemize}

\textbf{Testklasse: CommandOpenTest, getestete Unit: CommandOpen}
\begin{itemize}
	\item[--] \texttt{readingTest()}:\impl\\
	Versucht, eine Datei über die Leseroutine des Kommandos erfolgreich einzulesen.
	\item[--] \texttt{uiUpdateTest()}:\impl\\
	Versucht, den Editor nach dem Öffnen der Datei über die Aktualisierungsroutine des Kommandos erfolgreich zu aktualisieren.
	\item[--] \texttt{errorOutputTest()}:\qa\\
	Versucht, einen Fehler über die Fehlerausgaberoutine des Kommandos erfolgreich auszugeben.
	\item[--] \texttt{directOpenTest()}:\qa\\
	Versucht, eine Datei über das Kommando direkt zu öffnen. Dies sollte den Editor aktualisieren und eine Ausgabe in der Konsole erzeugen.
	\item[--] \texttt{dialogWithoutChangesTest()}:\qa\\
	Versucht, eine Datei über den Auswahldialog erfolgreich zu öffnen, ohne das ungespeicherte Änderungen vorhanden sind.
	\item[--] \texttt{dialogAndSaveTest()}:\qa\\
	Versucht, eine Datei über den Auswahldialog erfolgreich zu öffnen und ungespeicherte Änderungen dabei zu speichern.
	\item[--] \texttt{dialogAndDoNotSaveTest()}:\qa\\
	Versucht, eine Datei über den Auswahldialog erfolgreich zu öffnen und ungespeicherte Änderungen dabei nicht zu speichern.
	\item[--] \texttt{dialogAndCancelSaveTest()}:\qa\\
	Versucht, eine Datei über den Auswahldialog erfolgreich zu öffnen und den Vorgang bei der Meldung ungespeicherter Änderungen abzubrechen.
\end{itemize}

\textbf{Testklasse: CommandParseQueryTest, getestete Unit: CommandParseQuery}
\begin{itemize}
	\item[--] \texttt{validQueryTest()}:\qa\\
	Versucht, eine valide Abfrage erfolgreich zu parsen.
	\item[--] \texttt{invalidQueryTest()}:\qa\\
	Versucht, eine invalide Abfrage zu parsen. Dies sollte scheitern.
\end{itemize}

\textbf{Testklasse: CommandParseTest, getestete Unit: CommandParse}
\begin{itemize}
	\item[--] \texttt{emptyTest()}:\impl\\
	Versucht, den Quelltext aus einem leeren Editor erfolgreich zu parsen.
	\item[--] \texttt{incorrectSyntaxTest()}:\impl\\
	Versucht, inkorrekten Quelltext aus dem Editor zu parsen. Dies sollte scheitern.
	\item[--] \texttt{simpsonsTest()}:\impl\\
	Versucht, das Simpsons-Beispiel aus dem Pflichtenheft erfolgreich zu parsen.
	\item[--] \texttt{conflictingTest()}:\qa\\
	Versucht, Quelltext aus dem Editor zu parsen, welcher Regeln enthält, die mit der aktiven Standardbibliothek konfligiert. Dies sollte eine Warnung in der Konsole erzeugen.
\end{itemize}

\textbf{Testklasse: CommandSaveTest, getestete Unit: CommandSave}
\begin{itemize}
	\item[--] \texttt{emptySavedFileTest()}:\impl\\
	Versucht, leeren Quelltext aus dem Editor erfolgreich zu speichern.
	\item[--] \texttt{simpsonsSavedFileTest()}:\impl\\
	Versucht, das Simpsons-Beispiel aus dem Pflichtenheft erfolgreich zu speichern.
	\item[--] \texttt{writeTest()}:\impl\\
	Versucht, Quelltext aus dem Editor über die Schreibroutine des Kommandos erfolgreich zu speichern.
	\item[--] \texttt{dialogTest()}:\qa\\
	Versucht, Quelltext aus dem Editor über einen Dialog erfolgreich zu speichern.
	\item[--] \texttt{errorOutputTest()}:\qa\\
	Versucht, einen Fehler über die Ausgaberoutine der Konsole erfolgreich auszugeben.	
\end{itemize}

\textbf{Testklasse: CommandSetLangTest, getestete Unit: CommandSetLang}
\begin{itemize}
	\item[--] \texttt{allLocalesTest()}:\impl\\
	Versucht, alle unterstützten Sprachen einmal erfolgreich zu setzen.
	\item[--] \texttt{englishTest()}:\qa\\
	Versucht, die Sprache bei verschiedenen Zuständen des Programms (vor dem Parsen und während der Interpretation) erfolgreich auf Englisch zu setzen.
	\item[--] \texttt{unsupportedLocaleTest()}:\qa\\
	Versucht, eine nicht unterstützte Sprache zu setzen. Dies sollte scheitern und die zuvor gesetzte Sprache sollte erhalten bleiben.
\end{itemize}

\textbf{Testklasse: CommandShowAboutTest, getestete Unit: CommandShowAbout}
\begin{itemize}
	\item[--] \texttt{uiTest()}:\qa\\
	Versucht, das Popup erfolgreich zu erstellen und anzuzeigen.
\end{itemize}

\textbf{Testklasse: CommandShowManualTest, getestete Unit: CommandShowManual}
\begin{itemize}
	\item[--] \texttt{loadIconTest()}:\qa\\
	Versucht, die im Handbuch genutzten Icons erfolgreich zu laden.
	\item[--] \texttt{uiTest()}:\\
	Versucht, das Popup erfolgreich zu erstellen und anzuzeigen.
\end{itemize}

\textbf{Testklasse: CommandShowStandardTest, getestete Unit: CommandShowStandard}
\begin{itemize}
	\item[--] \texttt{uiTest()}:\qa\\
	Versucht, das Popup erfolgreich zu erstellen und anzuzeigen.
\end{itemize}

\textbf{Testklasse: CommandStepTest, getestete Unit: CommandStep}
\begin{itemize}
	\item[--] \texttt{singleSteppingTest()}:\qa\\
	Versucht, Einzelschritte in beide Richtungen bei der Interpretation erfolgreich auszuführen.
\end{itemize}

\textbf{Testklasse: CommandToggleLibTest, getestete Unit: CommandToggleLib}
\begin{itemize}
	\item[--] \texttt{switchOnAndOffTest()}:\impl\\
	Versucht, die Standardbibliothek erfolgreich an- und wieder auszustellen.
\end{itemize}

\textbf{Testklasse: CommandZoomTest, getestete Units: CommandZoom, CommandResetZoom}\\
\textbf{Anmerkung}: 4 der hier vorhandenen Tests werden aufgrund von Bugs innerhalb der RSyntaxTextArea"=Bibliothek, welche für den Editor genutzt wird, ignoriert. Diese funktionieren nicht zuverlässig aufgrund von Threading-Problemen, die nur innerhalb der Bibliothek reparierbar sind. Hierdurch schlagen die Tests in seltenen Fällen aufgrund einer NullPointerException beim Setzen der Schriftart fehl.
\begin{itemize}
	\item[--] \texttt{zoomingAllTest()}:\qa\\
	Versucht, den Editor, die Konsole und die Visualisierung erfolgreich hinein und hinaus zu zoomen. Wird ignoriert aus oben genanntem Grund.
	\item[--] \texttt{nullConsoleTest()}:\qa\\
	Versucht, den Editor und die Visualisierung erfolgreich hinein und hinaus zu zoomen. Wird ignoriert aus oben genanntem Grund.
	\item[--] \texttt{nullEditorTest()}:\qa\\
	Versucht, die Konsole und die Visualisierung erfolgreich hinein und hinaus zu zoomen.
	\item[--] \texttt{nullVisualisationTest()}:\qa\\
	Versucht, den Editor und die Konsole erfolgreich hinein und hinaus zu zoomen. Wird ignoriert aus oben genanntem Grund.
	\item[--] \texttt{commandResetZoomTest()}:\qa\\
	Versucht, den Editor, die Konsole und die Visualisierung nach einem Zoom erfolgreich zurückzusetzen. Wird ignoriert aus oben genanntem Grund.
\end{itemize}

\textbf{Testklasse: FileFiltersTest, getestete Unit: FileFilters}
\begin{itemize}
	\item[--] \texttt{defaultConstructorTest()}:\qa\\
	Testet den impliziten Default-Konstruktor. Dies sollte nichts bewirken und dient nur der Coverage.
	\item[--] \texttt{prologFilterTest()}:\impl\\
	Versucht, verschiedene Dateien durch den Dateifilter zu filtern. Dies sollte ausschließlich bei Dateien mit der Endung \glqq .pl\grqq (case-insensitive) erfolgreich sein.
	\item[--] \texttt{pngFilterTest()}:\impl\\
	Versucht, verschiedene Dateien durch den Dateifilter zu filtern. Dies sollte ausschließlich bei Dateien mit der Endung \glqq .png\grqq (case-insensitive) erfolgreich sein.
	\item[--] \texttt{svgFilterTest()}:\impl\\
	Versucht, verschiedene Dateien durch den Dateifilter zu filtern. Dies sollte ausschließlich bei Dateien mit der Endung \glqq .svg\grqq (case-insensitive) erfolgreich sein.
\end{itemize}

\textbf{Testklasse: FileUtilitiesTest, getestete Unit: FileUtilities}
\begin{itemize}
	\item[--] \texttt{defaultConstructorTest()}:\qa\\
	Testet den impliziten Default-Konstruktor. Dies sollte nichts bewirken und dient nur der Coverage.
	\item[--] \texttt{extensionAddingTest()}:\impl\\
	Versucht, Dateiendungen erfolgreich bei Bedarf an Dateien anzuhängen.
\end{itemize}

\textbf{Testklasse: InterpreterManagerTest, getestete Unit: InterpreterManager}
\begin{itemize}
	\item[--] \texttt{resetTest()}:\qa\\
	Versucht, die Interpretation bei der laufenden Suche nach einer Lösung erfolgreich über die Reset-Routine des InterpreterManagers zu unterbrechen.
	\item[--] \texttt{queryWithoutKnowledgeBaseTest()}:\qa\\
	Versucht, eine Abfrage ohne vorhandene KnowledgeBase zu interpretieren. Dies sollte scheitern.
	\item[--] \texttt{singleGoalTest()}:\qa\\
	Versucht, eine Abfrage mit einem einzelnen Ziel bis zur ersten Lösung zu interpretieren und diese erfolgreich abzugleichen.
	\item[--] \texttt{multipleGoalsTest()}:\qa\\
	Versucht, eine Abfrage mit mehreren Zielen bis zur ersten Lösung zu interpretieren und diese erfolgreich abzugleichen.
	\item[--] \texttt{threadingOperationsTest()}:\qa\\
	Versucht, riskante Threading-Situationen im Zusammenhang mit NextSolution und FinishQuery zu provozieren. Hierzu gehört das doppelte Starten einer Lösungssuche oder das zuweisen eines neuen Threads während der vorige noch aktiv ist, was die Interpretation nicht beeinflussen sollte. Ebenso gehört hierzu das Warten auf einen Thread, der nicht existiert, was sofort beendet sein sollte.
	\item[--] \texttt{steppingEdgeCasesTest()}:\qa\\
	Versucht, besondere Schritt-Situationen im Zusammenhang mit Einzelschritt"=Operationen zu provozieren. Hierzu gehört das Vor- und Zurückschreiten beim ersten Schritt der Interpretation sowie beim Stehen auf einer Lösung. Weiter wird hier auch das Suchen nach einer Lösung getestet, sobald man sich einen Einzelschritt vor der letzten Lösung befindet.
\end{itemize}

\textbf{Testklasse: PreferencesManagerTest, getestete Unit: PreferencesManager}
\begin{itemize}
	\item[--] \texttt{settingAndRetrievalTest()}:\qa\\
	Versucht, die Textgrößen-Eigenschaft erfolgreich zu setzen und zu erhalten, auch nachdem alle Eigenschaften gelöscht wurden (dies sollte den Standardwert zurückgeben).
	\item[--] \texttt{nullifiedPropertiesTest()}:\qa¸\\
	Versucht, verschiedene Eigenschaften zu erhalten, nachdem die Properties-Instanz auf null gesetzt wurde. Dies sollte entsprechende Standardwerte zurückgeben
\end{itemize}

\subsection{Testfälle aus Pflichtenheft}

\subsection{Statische Analyse und Linting}

\subsubsection{FindBugs}

Die statische Analyse des ByteCode mit FindBugs brachte die folgenden Ergebnisse hervor:

\begin{itemize}
  \item \textbf{Fehlende \texttt{hashCode} Methoden}\\
        In den Klassen des Models wurde für notwendige Vergleiche die Methode \texttt{java.lang.Object\#equals(Object)} überschrieben, die Methode \texttt{java.lang.Object\#hashCode()} allerdings nicht. Diese wurde in allen betroffenen Klassen ergänzt.
  \item \textbf{Schreiben in Klassenattribut}\\
        Die Hauptklasse (\texttt{MainWindow}) schreibt bei Initialisierung einen Wahrheitswert in das statische Klassenattribut \texttt{debug}, abhängig davon ob VIPER im Debug-Modus gestartet wurde oder nicht. Da die Abfrage dieses Wahrheitswertes allerdings statisch, d.h. ohne Instanz der Hauptklasse, möglich sein soll, wird diese Warnung ignoriert.
  \item \textbf{Rückgabewert \texttt{null} statt \texttt{Optional}}\\
        In der Methode \texttt{ActivationRecord\#getPrevious()} wurde in der letzten Zeile \texttt{null} statt einem \texttt{Optional<ActivationRecord>} zurückgegeben. Diese Zeile konnte nie erreicht werden, wurde aber vom Compiler gefordert. Die Methode wurde als Reaktion auf die Warnung von FindBugs umstrukturiert und neu implementiert.
\end{itemize}

\subsubsection{PMD}

Das Werkzeug PMD wurde sowohl zur Überprüfung von Semantik, als auch möglicher Fehler im Programm genutzt. Ebenfalls wurde der Quelltext auf unnötige und unerreichbare Zeilen sowie suboptimalen Code überprüft.

Das Ergebnis der Analyse sorgte für die folgenden Änderungen:

\begin{itemize}
  \item \textbf{Variablennamen überarbeitet}\\
        Sehr lange und sehr kurze Variablennamen wurden zugunsten der Verständlichkeit des Quelltextes umbenannt.
  \item \textbf{Aufruf von \texttt{super()}}\\
        Konstruktoren von Unterklassen, so beispielsweise alle Commands, wurden für guten Stil um einen Aufruf von \texttt{super()} ergänzt.
  \item \textbf{Finale Klassenattribute}\\
        Bereits in Konstruktoren initialisierte Klassenattribute wurden um das Schlüsselwort \texttt{final} ergänzt, um eine erneute, unerwünschte Zuweisung unmöglich zu machen.
  \item \textbf{Fest-codierte Konstanten in statische Klassenattribute ausgelagert}\\
        Im Quelltext verwendete Konstanten, wie beispielsweise von Swing zurückgegebene Zahlen bei betätigten Schaltflächen eines Dialogfensters, wurden in finale, statische Klassenattribute ausgelagert.
  \item \textbf{\texttt{return} als letztes Statement}\\
        Sofern möglich wurden alle Methoden so umgeschrieben, dass die letzte Zeile des Methodenkörpers ein \texttt{return} Statement darstellt. Dies verbessert die Lesbarkeit des Quelltextes durch weniger frühzeitige Methodenabbrüche.
  \item \textbf{Vermeiden von String-Konkatenation}\\
        Aufgrund der Unveränderbarkeit (\enquote{immutability}) von Strings in Java wurde im Quelltext verwendete String-Konkatenation für bessere Performance durch die \texttt{StringBuilder} Klasse ersetzt.
\end{itemize}

\subsubsection{Checkstyle}

Für einen einheitlichen Codestil im gesamten Projekt wird der Quelltext inklusive aller Tests von Checkstyle untersucht. Die Konfiguration stammt von der Vorlesung Programmieren \footnote{\url{https://sdqweb.ipd.kit.edu/wiki/Vorlesung_Programmieren_WS16/17}} und umfasst u.a. Regeln für maximale Klassengröße, Parameterzahl für Methoden, Leerzeichen vor und hinter geschwungenen Klammern, Einrückung mit Leerzeichen und einige mehr.

Die folgenden, eigenen Regeln erweitern die Konfiguration speziell für VIPER:

\begin{itemize}
  \item Geschweifte Klammern bei \texttt{if ... else} Blöcken und Schleifen sind immer notwendig, auch wenn der Körper nur eine Zeile umfasst.
  \item Das Schlüsselwort \texttt{this} muss immer verwendet werden, wenn auf Klassen-Attribute und -Methoden zugegriffen wird.
  \item Die maximale Parameteranzahl für Methoden beträgt 10, da einige Konstruktoren in Controller-Klassen viele Referenzen auf GUI Elemente oder andere Commands brauchen.
\end{itemize}

\subsection{Nutzerstudien}

Um VIPER von Außenstehenden testen und beurteilen zu lassen, wurden im Rahmen der Qualitätssicherungs-Phase mehrere Nutzerstudien durchgeführt.

Die Teilnehmer besaßen dabei unterschiedlich viele Vorkenntnisse in Prolog. Teilnehmern ohne Vorkenntnisse wurde die Funktionsweise anhand des \texttt{simpsons.pl} Beispielprogramms, welches mit VIPER mitgeliefert wird, kurz erläutert.

In den Studien lag der Fokus auf den folgenden Fragestellungen:

\begin{itemize}
  \item Wie intuitiv ist der Programm-Ablauf (Code eingeben, Parsen, Abfrage stellen, Änderungen machen, wieder Parsen, ...)?
  \item Lässt sich die Visualisierung gut bedienen? Wie funktioniert Zoomen und Bewegen? Sind die Funktionen der verschiedenen Schritte-Schaltflächen ersichtlich?
  \item Ist die grafische Oberfläche sinnvoll angeordnet? Findet man alle Funktionalitäten ohne lange suchen zu müssen?
  \item Ist die Menüleiste sinnvoll strukturiert? Erschließt sich die Funktion jeder Schaltfläche in der Werkzeugleiste durch das Icon?
  \item Genereller Eindruck vom Programm: Wie stabil läuft es, wie schnell reagiert das Programm Eingaben und Schaltflächen, wie performant sind Abfragen?
\end{itemize}

% Ergebnisse des Usability Testings (Reaktionen der Leute!)
% Icons geändert/Buttons aufgeteilt, Zoomen, Shortcuts, Stdlib anzeigen
% Zoom-Debatte mit Meinung von Max

\subsubsection{Studie 1} % Max

\subsubsection{Studie 2} % Alex

\subsubsection{Studie 3} % Sebi

\subsubsection{Studie 4} % Lennart

\section{Gefundene Fehler}

\begin{enumerate}[label=\#\arabic*]
  \item \textbf{\enquote{Nächster Schritt} Schaltfläche wird fälschlicherweise deaktiviert}\\
        Wird während einer Interpretation die \enquote{Vorheriger Schritt} Schaltfläche und anschließend die \enquote{Nächster Schritt} Schaltfläche betätigt, so wird danach letztere Schaltfläche deaktiviert und kann nicht mehr betätigt werden, obwohl es noch Schritte geben kann.\\\\
        \textbf{Grund:} Im Controller für die \enquote{Vorheriger Schritt} Schaltfläche wird der falsche Status der Schaltflächen (\texttt{ClickableState}) gesetzt. Dadurch werden die Schaltflächen nach einmaligem Betätigen der \enquote{Nächster Schritt} Schaltfläche deaktiviert.\\
        \textbf{Behebung:} Im entsprechenden Controller muss der korrekte Status der Schaltflächen gesetzt werden.

  \item \textbf{\enquote{Abbrechen} Schaltfläche wird nicht aktiviert}\\
        Wird die \enquote{Nächste Lösung} Schaltfläche betätigt und die Interpretation dauert etwas länger, so wird die \enquote{Abbrechen} Schaltfläche nicht aktiviert. Die Interpretation kann also nicht abgebrochen werden.\\\\
        \textbf{Grund:} Der Fall, dass vor dem Betätigen der \enquote{Nächste Lösung} kein Einzelschritt gemacht wird, wurde nicht berücksichtigt. In diesem Fall wird der falsche Status der Schaltflächen (\texttt{ClickableState}) gesetzt.\\
        \textbf{Behebung:} Der entsprechende Controller muss den korrekten \texttt{ClickableState} setzen.

  \item \textbf{Standardbibliothek kann nicht korrekt geladen werden}\\
        Wird VIPER als eine kompilierte \texttt{.jar} Datei gestartet, so wirft das Parsen eines Prolog-Programms bei aktivierter Standardbibliothek eine \texttt{FileSystemNotFoundException}. Das Parsen ist trotzdem möglich, es erscheint eine Fehlermeldung in der Konsole und die Regeln aus der Standardbibliothek sind nicht verfügbar.\\\\
        \textbf{Grund:} Während der Entwicklung wird VIPER über das verwendete Build-Management-Tool Gradle gestartet. Die Exception tritt in diesem Fall nicht auf.\\
        \textbf{Behebung:} Die in der \texttt{.jar} Datei enthaltene Standardbibliothek muss über einen Java Stream eingelesen werden, anstatt als Datei behandelt und geöffnet zu werden.

  \item \textbf{Im \enquote{Standardbibliothek anzeigen} Fenster ist kein Scrollen möglich}\\
        Über den Menüpunkt \enquote{Standardbibliothek anzeigen} lässt sich der Inhalt der Standardbibliothek in einem neuen Fenstern anzeigen. Bei langem Quelltext ist in diesem Fenster kein Scrollen möglich, der Inhalt wird am unteren Fensterrand abgeschnitten.\\\\
        \textbf{Grund:} Bevor die Standardbibliothek erweitert wurde, war der Quelltext nie zu lang für das Fenster. Somit ist der Fehler nie aufgefallen.\\
        \textbf{Behebung:} Das zum Anzeigen des Inhalts verwendete Textfeld muss in einem Java Swing \texttt{JScrollPane} eingebettet werden, damit Scrollen möglich ist.

  \item \textbf{Hinweis \enquote{Neue Abfrage eingeben...} wird in Historie gespeichert}\\
        Der Platzhalter-Text \enquote{Neue Abfrage eingeben...} wird beim Absenden einer Abfrage mit in der Historie gespeichert. Somit wird dieser Text sichtbar, wenn mit den Pfeiltasten durch die Historie gewechselt wird.\\\\
        \textbf{Grund:} Da es in Swing keine eingebauten Platzhalter für Textfelder gibt, wurde diese Funktionalität selbst implementiert. Der Platzhalter-Text wird dabei als normaler Text eingefügt und in der Farbe verändert. Dies wurde bei Implementierung der Historie-Funktionalität nicht beachtet und der Platzhalter als eingegebene Abfrage behandelt.\\
        \textbf{Behebung:} Beim Hinzufügen eines Eintrags zur Historie wird geprüft, ob es sich um den Platzhalter-Text handelt. Falls ja wird abgebrochen und der Eintrag nicht hinzugefügt.

  \item \textbf{Integer Overflow bei Abfragen mit großem Ergebnis}\\
        Bei Abfragen wie \texttt{fac(42, X).} (Fakultät von 42) kommt es zu einem Integer Overflow der JVM.\\\\
        \textbf{Grund:} Im Model wird der primitive Datentyp \texttt{int} verwendet, welcher nur Ganzzahlen mit einer Größe zwischen $-2^{31}$ und $2^{31}-1$ darstellen kann. Bei Werten außerhalb dieses Bereiches kommt es zu einem Overflow.\\
        \textbf{Behebung:} Im Model wird statt \texttt{int} die Klasse \texttt{BigInteger} verwendet, welche theoretisch unendlich große Ganzzahlen erlaubt.

  \item \textbf{Nach dem Formatieren eines Programmes muss neu geparst werden}\\
        Wird ein Programm formatiert, so wird die Eingabe gesperrt und es muss neu geparsed werden.\\\\
        \textbf{Grund:} Formatieren setzt den Text im Eingabefeld. Bei Änderungen des Textfeldes werden Codeänderungen vermutet und deshalb die Eingabe gesperrt. Ein neues Parsen ist dann nötig. \\
        \textbf{Behebung:} Einführen von isFormattingProcess EditorPanel. Während eines Formatierungsprozesses werden nun keine Codeänderungen mehr angenommen, und die Eingabe wird nicht mehr gesperrt.

  \item \textbf{Text im Eingabefeld ist hellgrau}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{Batik wirft \texttt{NullPointerException}s}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{\enquote{Vorheriger Schritt} Schaltfläche wird nicht aktiviert}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{Textgröße wird doppelt in Konfigurationsdatei gespeichert}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{In der Konsole werden lange Wörter nicht umgebrochen}\\
        Lange Wörter oder Dateinamen im Konsolenfenster werden nicht umgebrochen.\\\\
        \textbf{Grund:} Das verwendete JTextPane bricht nur bei Leerzeichen um.\\
        \textbf{Behebung:} Implementierung eines CustomEditorKit, welcher sich um bessere Zeilenumbrüche auch bei langen Wörtern und Pfäden kümmert.

  \item \textbf{Swing wirft \texttt{NullPointerException}s}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{Minimale und maximale Zoomstufe werden überschritten}\\
        Beschreibung\\\\
        \textbf{Grund:} Grund\\
        \textbf{Behebung:} Behebung

  \item \textbf{Texte in der Visualisierung ragen über Umrandung hinaus}\\
        In den SVGs der Visualisierung ragt Text um seine Umrandung heraus oder ist zu klein und nicht zentriert.\\\\
        \textbf{Grund:} graphiz-java berechnet die Rahmengröße auf Basis der Textgröße von Times New Roman. Viele Betriebssystem (z.B. Ubuntu) haben kein Times New Roman, oder nur anders große Ersatzfonts.\\
        \textbf{Behebung:} Implementieren und nutzen von Liberation Serif für die Visualisierung. Liberation Serif entspricht in Art und Größe dem bekannten, proprietären Times New Roman.
\end{enumerate}

\section{Zusätzliche Features}

Im Zuge der Verbesserung der Gebrauchstauglichkeit (\enquote{usability}) von VIPER wurde das Programm um einige Funktionalitäten erweitert.\\
Diese haben sich u.a. aus den Rückmeldungen von Testpersonen unseres Programms ergeben.\\\\
Im Folgenden werden die zusätzlich implementieren Funktionalitäten und Änderungen kurz erläutert.

\begin{itemize}
  \item \textbf{Nächste Lösung}\\
        Die Funktion der \enquote{Nächste Lösung} Schaltfläche wurde dahingehend verändert, dass nun die nächste auftretende Lösung, ausgehend vom aktuell angezeigten Schritt, ausgegeben wird. Bisher wurde bis zur nächsten, noch nicht berechneten Lösung gesprungen.
  \item \textbf{Letzte Lösung}\\
        Um für eine eingegebene Abfrage alle möglichen Lösungen anzeigen zu lassen, wurde die \enquote{Letzte Lösung} Schaltfläche in der Werkzeugleiste eingeführt. Diese berechnet direkt alle Schritte der Abfrage und zeigt alle gefundenen Lösungen in der Konsole an.
  \item \textbf{Neue Icons für alle \enquote{Schritt}-Schaltflächen}\\
        % TODO
  \item \textbf{Indikator für erfolgreiche Unifikation}\\
        Ist die Unifikation eines (Teil-)Ziels erfolgreich, so wird der dazugehörige Knoten in der Visualisierung nun grün eingefärbt und um ein Häkchen (\ding{51}) ergänzt.
  \item \textbf{\texttt{BigInteger} für Berechnung von Lösungen}\\
        Alle Model Klassen verwenden jetzt Java's \texttt{BigInteger} statt dem primitiven Datentyp \texttt{int}. Somit sind bei Berechnungen beliebig große Zahlen ohne Auftreten von einem Integer Overflow möglich.
  \item \textbf{Maximale Auführungstiefe für Abfragen}\\
        % TODO
  \item \textbf{Schönere Visualisierung des Cut}\\
        % TODO
  \item \textbf{Menüpunkt \enquote{Hilfe}}\\
        Die Menüleiste wurde um den Eintrag \enquote{Hilfe} erweitert, der Optionen zum Anzeigen einer Anleitung für das Programm, des Inhalts der Standardbibliothek sowie eines \enquote{Über}-Dialogs enthält.
  \item \textbf{Anleitung}\\
        In der neu hinzugekommenen Anleitung wird dem Nutzer die grundlegende Arbeitsweise des Programms nahegelegt. Zusätzlich enthält sie eine Legende zu den Bedeutungen der Farben in der Konsole, sowie eine Hilfe zur Bedienung des Editors, der Visualisierung und der Schritt-Schaltflächen.
  \item \textbf{Inhalt der Standardbibliothek}\\
        Die Standardbibliothek wurde um einige, aus der Vorlesung \enquote{Programmierparadigmen} bekannte, Regeln ergänzt. Dazu gehören beispielsweise Listen-Sortierung, Quadratwurzel-Berechnung und Summenbildung.
  \item \textbf{Hinweis bei Namenskonflikten mit der Standardbibliothek}\\
        Falls im geparsten Programm Regeln vorkommen, die Namenskonflikte mit Regeln aus der Standardbibliothek hervorrufen, so wird eine Warnung in der Konsole ausgegeben. Ist die Standardbibliothek nicht aktiviert, so wird der Hinweis nicht angezeigt.
  \item \textbf{Beispielprogramme}\\
        Mehrere Beispiel-Programme, darunter das aus dem Pflichtenheft bekannte \texttt{simpsons.pl} Programm, werden nun mit VIPER mitgeliefert und können über den \enquote{Datei}-Menüpunkt in den Editor geladen werden.
  \item \textbf{Tastenkombinationen für den Editor}\\
        Um die Nutzbarkeit des Editors zu verbessern, wurde er um gebräuchliche Tastaturkürzel wie Strg+O zum Öffnen und Strg+S zum Speichern einer Datei erweitert.
  \item \textbf{Ungespeicherte Änderungen}\\
        Auf im Editor durchgeführte Änderungen, welche noch nicht auf dem Dateisystem gespeichert wurden, wird mit einem Sternchen (*) im Fenstertitel hingewiesen.
  \item \textbf{Mitgelieferte Schriftart für Visualisierung}\\
        Um ein einheitliches Aussehen der Visualisierung auf allen Betriebssystemen garantieren zu können, wird die freie Schriftart \enquote{Liberation Serif} von Red Hat im Programm mitgeliefert. Diese wird für alle Texte und Zeichen in der Visualisierung verwendet.
  \item \textbf{Zoom an der Position des Mauszeigers}\\
        Wird in der Visualisierung mittels des Mausrads der angezeigte Graph vergrößert oder verkleinert, so wird die Richtung des Zooms über die Position des Mauszeigers über dem Graphen bestimmt. Bisher wurde in der Visualisierung zentral herein- bzw. herausgezoomt. Außerdem wurde die Sensitivität beim Zoomen mit dem Mausrad verringert.
  \item \textbf{Änderung der Schriftgröße in Editor und Konsole}\\
        Um die Schriftgröße des Editors und der Konsole anpassen zu können, wurden zwei Schaltflächen \enquote{+} und \enquote{-} ähnlich denen in der Visualisierung hinzugefügt. Die Schaltflächen befinden sich in der Werkzeugleiste und verändern gleichzeitig die Schriftgröße des Editors sowie der Konsole. Diese Einstellung wird außerdem gespeichert und bleibt nach einem Programm-Neustart erhalten.
  \item \textbf{Platzhalter-Hinweise}\\
        Wurde noch keine Visualisierung gestartet, so wird im Visualisierungs-Bereich der Hinweis \enquote{Bitte Quelltext parsen und eine Abfrage eingeben, um die Visualisierung zu starten} angezeigt. Außerdem ist im Eingabefeld der Hinweis \enquote{Neue Abfrage eingeben...} sichtbar, sollte es nicht fokussiert sein.
  \item \textbf{Darstellung des Mauszeigers}\\
        Der Mauszeiger ändert seine Darstellung zur \enquote{Laden...}-Animation, wenn die Berechnung der nächsten Lösung etwas Zeit in Anspruch nimmt.
\end{itemize}

\section{Statistiken}

% Testabdeckung mit JUnit, möglichst detailliert (Tests pro Paket, LoC an Tests pro Palet, wie viele Tests laufen vollautomatisch).
% Commits und LoC der Phase insg.
% Monkey Testing Ergebnisse

\end{document}
