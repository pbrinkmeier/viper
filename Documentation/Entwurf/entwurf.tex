\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER Interactive Prolog Education Runtime}
\subtitle{Entwurf}
\author{Paul Brinkmeier, Lukas Brocke, Jannik Koch, Aaron Maier, Christian Oder}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{multicol}
\hypersetup{
	pdftitle={Entwurf},
}

\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\lstset{basicstyle=\ttfamily,breaklines=true}

% Don't strech across whole page
\raggedbottom

% Start new page with each section
\usepackage{sectsty}
\sectionfont{\clearpage}

\begin{document}
\maketitle

\section{Einleitung}

\section{Klassenbeschreibungen}

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.model}}

Repräsentation der Model-Komponente im Kontext des Model-View-Controller Architekturstils. Dies umfasst die internen Datenstrukturen wie beispielsweise den Interpreter, den Parser oder den abstrakten Syntaxbaum. Kommandos aus der Controller-Komponente, welche durch die View-Komponente ausgelöst werden, erzeugen Änderungen in der Model-Komponente wie beispielsweise das Voranschreiten der Interpretation.

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.model.ast}}

Enthält Klassen, welche den abstrakten Syntax-Baum (\enquote{abstract syntax tree}) der Prolog-Sprache modellieren. Hierzu gehören u.a. Terme (\texttt{Term}), Variablen (\texttt{Variable}), die Wissensdatenbank (\texttt{KnowledgeBase}) sowie verschiedene Unifikationsziele (\texttt{FunctorGoal}, \texttt{ArithmeticGoal}, \dots).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{KnowledgeBase}}
TODO

\textbf{\texttt{public KnowledgeBase(List<Rule> rules)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{rules}: TODO
\end{itemize}
TODO

\textbf{\texttt{public List<Rule> getMatchingRules(Functor head)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{head}: TODO
	\item[-] Returns \texttt{List<Rule>}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Rule}}
TODO

\textbf{\texttt{public Rule(Functor head, List<Goal> subgoals)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{head}: TODO
	\item[-] \texttt{subgoals}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Functor getHead()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\textbf{\texttt{public List<Goal> getSubgoals()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{List<Goal>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String toString()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Abstrakte Klasse \texttt{Term}}
TODO

\textbf{\texttt{public abstract ResultType accept(TermVisitor<ResultType>\\visitor)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{visitor}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract Number evaluate()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Number}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract String toString()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract String toHtml()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\subsubsection{Abstrakte Klasse \texttt{TermEvaluationException} erbt von\\\texttt{java.lang.Exception}}
TODO

\textbf{\texttt{public abstract String getMessage()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{UnsetVariableException} erbt von\\\texttt{TermEvaluationException}}
TODO

\textbf{\texttt{public UnsetVariableException(Variable var)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{var}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{UnsupportedTermException} erbt von\\\texttt{TermEvaluationException}}
TODO

\textbf{\texttt{public UnsupportedTermException(Term term)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Number} erbt von \texttt{Term}}
TODO

\textbf{\texttt{public Number(int number)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{number}: TODO
\end{itemize}
TODO

\textbf{\texttt{public int getNumber()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{int}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Variable} erbt von \texttt{Term}}
TODO

\textbf{\texttt{public Variable(String name, Integer index)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{name}: TODO
	\item[-] \texttt{index}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String getName()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Optional<Integer> getIndex()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<Integer>}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Functor} erbt von \texttt{Term}}
TODO

\textbf{\texttt{public Functor(String name, List<Term> subTerms)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{name}: TODO
	\item[-] \texttt{subTerms}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String getName()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public List<Term> getSubTerms()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{List<Term>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Functor createNew(String name, List<Term>\\subTerms)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{name}: TODO
	\item[-] \texttt{subTerms}: TODO
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\textbf{\texttt{public int getArity()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{int}: TODO
\end{itemize}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Abstrakte Klasse \texttt{BinaryOperation} erbt von \texttt{Functor}}
TODO

\textbf{\texttt{public BinaryOperation(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Number evaluate(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
	\item[-] Returns \texttt{Number}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected int calculate(int a, int b)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{a}: TODO
	\item[-] \texttt{b}: TODO
	\item[-] Returns \texttt{int}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String toString()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String toHtml()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract BinaryOperation createNew(String head,\\List<Term> subTerms)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{head}: TODO
	\item[-] \texttt{subTerms}: TODO
	\item[-] Returns \texttt{BinaryOperation}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{AdditionOperation} erbt von \texttt{BinaryOperation}}
TODO

\textbf{\texttt{public AdditionOperation(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{SubtractionOperation} erbt von \texttt{BinaryOperation}}
TODO

\textbf{\texttt{public SubtractionOperation(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{MultiplicationOperation} erbt von \texttt{BinaryOperation}}
TODO

\textbf{\texttt{public MultiplicationOperation(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Interface \texttt{TermVisitor<ResultType>}}
TODO

\textbf{\texttt{public ResultType visit(Functor fun)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{fun}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{public ResultType visit(Variable var)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{var}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{public ResultType visit(Number num)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{num}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\subsubsection{Interface \texttt{TermTransformationVisitor}}
TODO

\textbf{\texttt{public Functor visit(Functor functor)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{functor}: TODO
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Variable visit(Variable var)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{var}: TODO
	\item[-] Returns \texttt{Variable}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Number visit(Number num)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{num}: TODO
	\item[-] Returns \texttt{Number}: TODO
\end{itemize}
TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Abstrakte Klasse \texttt{Goal}}
TODO

\textbf{\texttt{public abstract ActivationRecord createActivationRecord\\(Optional<ActivationRecord> parent)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract String toString()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{CutGoal} erbt von \texttt{Goal}}
TODO

\textbf{\texttt{public CutGoal()}}
TODO

\subsubsection{Klasse \texttt{FunctorGoal} erbt von \texttt{Goal}}
TODO

\textbf{\texttt{public FunctorGoal(Functor goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{goal}: TODO
	\item[-] Returns \texttt{FunctorGoal}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Functor getFunctor()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{ArithmeticGoal} erbt von \texttt{Goal}}
TODO

\textbf{\texttt{public ArithmeticGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getLhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getRhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{UnificationGoal} erbt von \texttt{Goal}}
TODO

\textbf{\texttt{public UnificationGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getLhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getRhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{ComparisonGoal} erbt von \texttt{Goal}}
TODO

\textbf{\texttt{public ComparisonGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getLhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getRhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract boolean compareNumbers(int lhs, int rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
	\item[-] Returns \texttt{boolean}: TODO
\end{itemize}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{LessThanGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public LessThanGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{LessThanEqualGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public LessThanEqualGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{GreaterThanGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public GreaterThanGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{GreaterThanEqualGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public GreaterThanEqualGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{EqualGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public EqualGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{NotEqualGoal} erbt von \texttt{ComparisonGoal}}
TODO

\textbf{\texttt{public NotEqualGoal(Term lhs, Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
\end{itemize}
TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\subsection{Paket \texttt{edu.kit.ipd.pp.viper.model.parser}}

Das Parser-Paket enhält mehrere Klassen, welche für die Generierung eines abstrakten Syntax-Baums aus einem gegebenen Prolog-Programm zuständig sind.

\subsubsection{Klasse \texttt{PrologParser}}

Die PrologParser Klasse ist in der Lage, einen gegebenen, korrekten Prolog-Programmcode in eine intere Datenstruktur umzuwandeln. Bei inkorrekten Prolog-Programmen wird eine ParseException geworfen.

\textbf{\texttt{public PrologParser(String program)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{program}: Der zu parsende Prolog-Programmcode
	\item[-] Throws \texttt{ParseException}: Der gegebene Prolog-Programmcode konnte aufgrund von Syntax-Fehlern nicht geparst werden.
\end{itemize}
Erstellt eine neue Instanz des Parsers zu einem gegebenen Prolog-Programmcode.

\textbf{\texttt{public KnowledgeBase parseKnowledgeBase()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{KnowledgeBase}: Die geparste Wissensdatenbank
\end{itemize}
Gibt die vom Parser in einen abstrakten Syntax-Baum umgewandelte Wissensdatenbank aus dem geparsten Prolo-Programm zurück.

\textbf{\texttt{public List<Goal> parseGoalList()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{List<Goal>}: Liste von gefundenen Zielen
\end{itemize}
Gibt eine Liste von gefundenen Zielen zurück.

\subsubsection{Klasse \texttt{PrologLexer}}

Der Lexer trennt das gegebene Prolog-Programm in sinnvolle Zeichen, d.h. Schlüsselwörtel, Trennzeichen, arithmetische Operatoren, Variablen, Zahlen etc. auf. Diese Teile werden als Token bezeichnet und besitzen je einen Typ (\texttt{TokenType}), sowie Zeilen- und Positionsangabe. Der Lexer beginnt in der ersten Zeile, an der ersten Position des Prolog-Programms und arbeitet sich bis zu letzten Zeile durch.

\textbf{\texttt{public PrologLexer(String program)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{program}: Das aufzuteilende Prolog-Programm
\end{itemize}
Erstellt ein neue Instanz vom Lexer zu einem gegebenen Prolog-Programm.

\textbf{\texttt{public Token nextToken()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Token}: Der nächste gefundenen Token. Das Ende des Prolog-Programms wird durch einen Token mit dem Typ \texttt{TokenType.EOF} angegeben
\end{itemize}
Gibt den nächsten gefundenen Token des Prolog-Programms zurück.

\subsubsection{Klasse \texttt{PrologException} erbt von \texttt{java.lang.Exception}}

Eine eigene Exception, die vom Parser und Lexer im Falle von Syntax-Fehlern geworfen wird.

\textbf{\texttt{public PrologException(String message)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{message}: Die Fehlernachricht
\end{itemize}
Erstellt eine neue Exception mit einer gegebenen Fehlermeldung.

\subsubsection{Klasse \texttt{Token}}

Ein Token stellt ein in Prolog sinnvolles Zeichen dar, d.h. Schlüsselwörter, Trennzeichen, arithmetische Operatoren etc. Identifier, Variablen und Zahlen sind ebenfalls Tokens, auch wenn diese möglicherweise aus mehr als einem Zeichen bestehen.

\textbf{\texttt{public Token(TokenType type, String text, int line, int col)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{type}: Typ dieses Tokens, d.h. ein arithmetische Operator, ein Trennzeichen, eine Klammer, eine Variable etc.
	\item[-] \texttt{text}: Ein oder mehrere Zeichen aus dem Prolog-Programm, welche dieses Token darstellen
	\item[-] \texttt{line}: Zeile, in welcher dieses Token gefunden wurde
	\item[-] \texttt{col}: Position innerhalb einer Zeile, an welcher dieses Token gefunden wurde
\end{itemize}
Erstellt ein neues, unveränderliches (\texttt{immutable}) Token mit einem Typ, einem oder mehreren Zeichen (die dieses Token darstellen), sowie einer Positionsangabe.

\textbf{\texttt{public TokenType getType()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{TokenType}: Typ dieses Tokens
\end{itemize}
Gibt den Typ dieses Tokens zurück (arithmetischer Operator, Trennzeichen, Klammer, Variable, \dots)

\textbf{\texttt{public String getText()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Ein oder mehrere Zeichen, die dieses Token darstellen
\end{itemize}
Gibt das tatsächliche Zeichen oder die tatsächlichen Zeichen aus dem Prolog-Programm zurück, die dieses Token darstellen.

\textbf{\texttt{public int getLine()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{int}: Nummer der Zeile dieses Tokens
\end{itemize}
Gibt die Nummer der Zeile zurück, in der dieses Token gefunden wurde.

\textbf{\texttt{public int getCol()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{int}: Position dieses Tokens in der Zeile
\end{itemize}
Gibt die Position innerhalb der Zeile zurück, in der dieses Token gefunden wurde.

\textbf{\texttt{public String toString()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Lesbare Darstellung des Tokens
\end{itemize}
Gibt eine lesbare Darstellung des Tokens zurück, welche beispielsweise für Fehlermeldungen verwendet werden kann.

\subsubsection{Enum \texttt{TokenType}}

Stellt den Typ eines Tokens dar, d.h. eine arithmetische Operation, ein Trennzeichen, eine Klammer, eine Variable etc.

\textbf{\texttt{TokenType.COLON\_MINUS}}\\
Operator für zu erfüllende Teilziele (\texttt{:-}).

\textbf{\texttt{TokenType.EQ}}\\
Das Gleich-Zeichen (\texttt{=}).

\textbf{\texttt{TokenType.LESS}}\\
Das Kleiner-Zeichen (\texttt{<}).

\textbf{\texttt{TokenType.EQ\_LESS}}\\
Das Kleiner-Gleich-Zeichen (\texttt{=<}).

\textbf{\texttt{TokenType.GREATER}}\\
Das Größer-Zeichen (\texttt{<}).

\textbf{\texttt{TokenType.GREATER\_EQ}}\\
Das Größer-Gleich-Zeichen (\texttt{>=}).

\textbf{\texttt{TokenType.EQ\_COLON\_EQ}}\\
Das Gleichheit-Zeichen (\texttt{=:=}).

\textbf{\texttt{TokenType.EQ\_BS\_EQ}}\\
Das Ungleichheit-Zeichen (\texttt{=\=}).

\textbf{\texttt{TokenType.EOF}}\\
Gibt das Ende des Prolog-Programms an (\enquote{End of file}).

\textbf{\texttt{TokenType.DOT}}\\
Ein Punkt (\texttt{.}).

\textbf{\texttt{TokenType.COMMA}}\\
Ein Komman (\texttt{,}).

\textbf{\texttt{TokenType.LP}}\\
Die öffnende, runde Klammer (\texttt{(}).

\textbf{\texttt{TokenType.RP}}\\
Die schließende, runde Klammer (\texttt{)}).

\textbf{\texttt{TokenType.LB}}\\
Die öffnende, eckige Klammer (\texttt{[}).

\textbf{\texttt{TokenType.RB}}\\
Die schließende, eckige Klammer (\texttt{]}).

\textbf{\texttt{TokenType.BAR}}\\
Der vertikale Strich (\texttt{|}).

\textbf{\texttt{TokenType.PLUS}}\\
Das Plus-Zeichen (\texttt{+}).

\textbf{\texttt{TokenType.MINUS}}\\
Das Minus-Zeichen (\texttt{-}).

\textbf{\texttt{TokenType.STAR}}\\
Das Sternchen-Zeichen (\texttt{*}).

\textbf{\texttt{TokenType.EXCLAMATION}}\\
Das Ausrufe-Zeichen (\texttt{!}).

\textbf{\texttt{TokenType.IS}}\\
Das Schlüsselwort für arithmetische Gleichzeit (\texttt{is}).

\textbf{\texttt{TokenType.VARIABLE}}\\
Eine Variable (Mindestens ein Großbuchstabe, gefolgt von beliebig vielen weiteren Buchstaben und Zahlen).

\textbf{\texttt{TokenType.IDENTIFIER}}\\
Ein Identifier (Mindestens ein Kleinbuchstabe, gefolgt von beliebig vielen weiteren Buchstaben und Zahlen).

\textbf{\texttt{TokenType.NUMBER}}\\
Eine Zahl.

\newpage
\subsection{Paket \texttt{edu.kit.ipd.pp.viper.model.interpreter}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{Interpreter}}
TODO

\textbf{\texttt{public Interpreter(KnowledgeBase kb, Goal query)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{kb}: TODO
	\item[-] \texttt{query}: TODO
\end{itemize}
TODO

\textbf{\texttt{public StepResult step()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{StepResult}: TODO
\end{itemize}
TODO

\textbf{\texttt{public ActivationRecord getQuery()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{public ActivationRecord getCurrent()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{public ActivationRecord getNext()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Interpreter copy()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Interpreter}: TODO
\end{itemize}
TODO

\subsubsection{Enum \texttt{StepResult}}
TODO\\

\textbf{\texttt{StepResult.NO\_MORE\_SOLUTIONS}}\\
TODO

\textbf{\texttt{StepResult.SOLUTION\_FOUND}}\\
TODO

\textbf{\texttt{StepResult.STEPS\_REMAINING}}\\
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{Environment}}
TODO

\textbf{\texttt{public Environment(ActivationRecord ar, List<Substitution>\\ substitutions)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{ar}: TODO
	\item[-] \texttt{substitutions}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term applyAllSubstitutions(Term term)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{term}: TODO
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Substitution}}
TODO

\textbf{\texttt{public Substitution(Variable replace, Term by)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{replace}: TODO
	\item[-] \texttt{by}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Variable getReplace()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Variable}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getBy()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{SubstitutionApplier} implementiert \texttt{TermTransformationVisitor}}
TODO

\textbf{\texttt{public SubstitutionApplier(Substitution subst)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{subst}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{Indexifier} implementiert \texttt{TermTransformationVisitor}}
TODO

\textbf{\texttt{public Indexifier(int index)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{index}: TODO
\end{itemize}
TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{UnificationResult}}
TODO

\textbf{\texttt{public UnificationResult()}}\\
TODO

\textbf{\texttt{public static UnificationResult success(List<Substitution>\\substitutions)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{substitutions}: TODO
	\item[-] \texttt{UnificationResult}: TODO
\end{itemize}
TODO

\textbf{\texttt{public static UnificationResult fail(Term lhs,\\Term rhs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{lhs}: TODO
	\item[-] \texttt{rhs}: TODO
	\item[-] \texttt{UnificationResult}: TODO
\end{itemize}
TODO

\textbf{\texttt{public boolean isSuccess()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{boolean}: TODO
\end{itemize}
TODO

\textbf{\texttt{public List<Substitution> getSubstitutions()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{List<Substitution>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String getErrorMessage()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

\textbf{\texttt{public String toHtml()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: TODO
\end{itemize}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Abstrakte Klasse \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public ActivationRecord(Interpreter interpreter,\\Optional<FunctorActivationRecord> parent)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{interpreter}: TODO
	\item[-] \texttt{parent}: TODO
\end{itemize}
TODO

\textbf{\texttt{public abstract ResultType accept\\(ActivationRecordVisitor<ResultType> visitor)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{visitor}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ActivationRecord step()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ActivationRecord createCopy()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected void setEnvironment(Environment env)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{env}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ActivationRecord getPrevious()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected Environment getEnvironment()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Environment}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ActivationRecord getNext()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ActivationRecord}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected Interpreter getInterpreter()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Interpreter}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected Optional<FunctorActivationRecord> getParent()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<FunctorActivationRecord>}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected boolean hasBeenVisited()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{boolean}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected void setVisited()}}
TODO

\subsubsection{Klasse \texttt{ArithmeticActivationRecord} erbt von \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public ArithmeticActivationRecord(Optional<ActivationRecord>\\parent, ArithmeticGoal goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] \texttt{goal}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Optional<UnificationResult> getUnificationResult()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<UnificationResult>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getLhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getRhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Optional<String> getEvaluationError()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<String>}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{ComparisonActivationRecord} erbt von \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public ComparisonActivationRecord(Optional<ActivationRecord>\\ parent, ComparisonGoal goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] \texttt{goal}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{CutActivationRecord} erbt von \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public CutActivationRecord(Optional<ActivationRecord>\\ parent, CutGoal goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] \texttt{goal}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{UnificationActivationRecord} erbt von \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public UnificationActivationRecord(Optional<ActivationRecord>\\ parent, UnificationGoal goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] \texttt{goal}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Optional<UnificationResult> getUnificationResult()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<UnificationResult>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getLhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Term getRhs()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Term}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{FunctorActivationRecord} erbt von \texttt{ActivationRecord}}
TODO

\textbf{\texttt{public FunctorActivationRecord(Optional<ActivationRecord>\\ parent, FunctorGoal goal)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{parent}: TODO
	\item[-] \texttt{goal}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Optional<UnificationResult> getUnificationResult()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Optional<UnificationResult>}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Functor getFunctor()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\textbf{\texttt{public Functor getMatchingRuleHead()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{Functor}: TODO
\end{itemize}
TODO

\textbf{\texttt{public int getRuleIndex()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{int}: TODO
\end{itemize}
TODO

\subsubsection{Interface \texttt{ActivationRecordVisitor<ResultType>}}
TODO

\textbf{\texttt{protected ResultType visit(FunctorActivationRecord\\functorAr)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{functorAr}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ResultType visit(UnificationActivationRecord\\unificationAr)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{unificationAr}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ResultType visit(CutActivationRecord cutAr)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{cutAr}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ResultType visit(ArithmeticActivationRecord\\arithAr)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{arithAr}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

\textbf{\texttt{protected ResultType visit(ComparisonActivationRecord\\compAr)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{compAr}: TODO
	\item[-] Returns \texttt{ResultType}: TODO
\end{itemize}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Klasse \texttt{VariableExtractor} implementiert \texttt{TermVisitor}}
TODO

\textbf{\texttt{public VariableExtractor()}}\\
TODO

\subsubsection{Abstrakte Klasse \texttt{Unifier}}
TODO

\subsubsection{Abstrakte Klasse \texttt{FunctorUnifier} erbt von \texttt{Unifier}}
TODO

\textbf{\texttt{public FunctorUnifier(Functor functor)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{functor}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{VariableUnifier} erbt von \texttt{Unifier}}
TODO

\textbf{\texttt{public VariableUnifier(Variable var)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{var}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{NumberUnifier} erbt von \texttt{Unifier}}
TODO

\textbf{\texttt{public NumberUnifier(Number num)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{num}: TODO
\end{itemize}
TODO

\subsubsection{Klasse \texttt{UnifierCreator}}
TODO

\textbf{\texttt{public UnifierCreator()}}\\
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Paket \texttt{edu.kit.ipd.pp.viper.model.visualisation}}

Beinhaltet Klassen, die für die Visualisierung des aktuellen Interpreter-Zustands zuständig sind.

\subsubsection{Klasse \texttt{GraphvizMaker}}

TODO

\textbf{\texttt{public GraphvizMaker(ActivationRecord root)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{root}: Wurzel-ActivationRecord der aktuellen Interpretation. Wird gleichzeitig als Wurzel des angezeigten Graphen verwendet
\end{itemize}
TODO

\subsubsection{Klasse \texttt{LatexMaker}}
TODO

\textbf{\texttt{public LatexMaker(ActivationRecord root)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{root}: Wurzel-ActivationRecord der aktuellen Interpretation. Wird gleichzeitig als Wurzel des angezeigten Graphen verwendet
\end{itemize}
TODO

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.view}}

Repräsentation der View-Komponente im Kontext des Model-View-Controller Architekturstils. Umfasst alle selbst implementierten Komponenten der grafischen Benutzeroberfläche, welche zur Darstellung der Inhalte der Model-Komponente dient. Interaktionen mit der Oberfläche werden über Commands aus dem Controller-Paket auf die internen Datenstrukturen des Model-Pakets angewandt.

\subsubsection{Klasse \texttt{Button} erbt von \texttt{javax.swing.JButton}}

Initialisiert eine neues Schaltflächen-Element für die GUI. Beim Betätigen der Schaltfläche wird ein entsprechender Befehl über den Controller ausgeführt.

\textbf{\texttt{public Button(String textKey, Command command)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen der Schaltfläche
\end{itemize}
Initialisiert die Schaltfläche mit dem auszuführenden Befehl. Weiterhin wird der Tooltip der Schaltfläche durch den übergebenen Schlüssel aus dem LanguageManager geholt und für die Schaltfläche gesetzt.

\subsubsection{Klasse \texttt{ConsoleInputField} erbt von \texttt{javax.swing.JTextField}}

Eingabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Ausgabefeld für den Nutzer editierbar und dient der Eingabe von Prolog-Abfragen. Außerdem ist das Eingabefeld sperrbar, um Eingaben durch den Nutzer zu verhindern, bis es wieder freigegeben wurde.

\textbf{\texttt{public ConsoleInputField()}}\\
Initialisiert ein leeres, editierbares Textfeld mit einer einzelnen Zeile.

\textbf{\texttt{public void clear()}}\\
Leert das Eingabefeld.

\textbf{\texttt{public void lock()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben durch den Nutzer möglich sind.

\textbf{\texttt{public void unlock()}}\\
Gibt das Eingabefeld frei, sodass Eingaben durch den Nutzer möglich sind. Das Eingabefeld wird vor der Freigabe geleert.

\subsubsection{Klasse \texttt{ConsoleOutputArea} erbt von \texttt{javax.swing.JTextField}}

Ausgabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Eingabefeld für den Nutzer ausschließlich lesbar und dient der Ausgabe von Informationen über den Stand des Programmes, Fehlermeldungen oder den Ergebnissen von Prolog-Abfragen. Einzelne Zeilen der Ausgabe können zur besseren visuellen Rückmeldung eingefärbt werden. Ausgaben werden am Ende der Zeile umgebrochen. Das Textfeld erlaubt das Scrollen durch alle ausgegebenen Zeilen, sollten diese die Anzahl gleichzeitig sichtbarer Zeilen überschreiten.

\textbf{\texttt{public ConsoleOutputArea()}}\\
Initialisiert ein leeres, vom Nutzer nur lesbares, Textfeld mit mehreren Zeilen.

\textbf{\texttt{public void printLine(String line, Color color)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{line}: Der anzuzeigende Text
	\item[-] \texttt{color}: Gewünschte Farbe für den gesamten Text
\end{itemize}
Gibt eine neue Zeile mit Text \texttt{line} in der Farbe \texttt{color} im Textfeld aus. Sollte bereits die unterste Zeile erreicht werden, werden alle Zeilen darüber nach oben geschoben und die neue Zeile unten angefügt.

\textbf{\texttt{public void clear()}}\\
Leert den Inhalt des Textfeldes.

\subsubsection{Klasse \texttt{ConsolePanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Bereich, welcher das Eingabe- und Ausgabefeld umfasst. Dieses Element bildet die Konsole und leitet Befehle an die einzelnen Konsolen-Elemente weiter.

\textbf{\texttt{public ConsolePanel()}}\\
Initialisiert das Eingabe- und Ausgabefeld.

\textbf{\texttt{public void clearAll()}}\\
Leert sowohl das Eingabe-, als auch das Ausgabefeld.

\textbf{\texttt{public void clearOutputArea()}}\\
Leert den Inhalt des Ausgabefeldes.

\textbf{\texttt{public void clearInputField()}}\\
Leert den Inhalt des Eingabefeldes.

\textbf{\texttt{public void lockInput()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben mehr möglich sind.

\textbf{\texttt{public void unlockInput()}}\\
Gibt das Eingabefeld frei, sodass Eingaben möglich sind. Der Inhalt wird dabei geleert.

\textbf{\texttt{public void printLine(String line, Color color)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{line}: Auszugebender Text
	\item[-] \texttt{color}: Farbe des Textes
\end{itemize}
Gibt eine Zeile mit dem Text \texttt{line} in der Farbe \texttt{color} auf der Konsole aus.

\textbf{\texttt{public String getText()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Der Text aus dem Eingabefeld
\end{itemize}
Gibt den vom Nutzer in das Eingabefeld eingegebenen Text zurück.

\subsubsection{Klasse \texttt{EditorPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Bereich, welcher das externe Editor-Element \texttt{RSyntaxTextArea} umschließt. Bietet Schnittstellen zum Setzen und Erhalten des Editor-Inhaltes an.

\textbf{\texttt{public EditorPanel()}}\\
Initialisiert einen leeren Editor und konfiguriert ihn für Prolog-Quelltext.

\textbf{\texttt{public String getSourceText()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Der aktuelle Editor-Inhalt
\end{itemize}
Gibt den aktuellen Inhalt des Editors zurück.

\textbf{\texttt{public void setSourceText(String text)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{text}: Gewünschter neuer Text für den Editor
\end{itemize}
Setzt den Inhalt des Editors auf den übergebenen String. Der vorherige Inhalt wird dabei verworfen.

\textbf{\texttt{public boolean hasChanged()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{boolean}: Änderungsstatus des Editors. \texttt{true} falls seit letztem Parser geändert worden, andernfalls \texttt{false}
\end{itemize}
Überprüft, ob der Text im Editor seit dem letzen Parser verändert wurde.

\textbf{\texttt{public void setHasChanged(boolean status)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{status}: Setzt den Änderungsstatus des Editors auf \texttt{true} oder \texttt{false}
\end{itemize}
Der Status kann mit \texttt{hasChanged()} abgefragt werden. Ein Setzen auf \texttt{true} hat das Löschen der Konsole sowie der angezeigten Visualisierung zur Folge.

\subsubsection{Klasse \texttt{MainWindow} erbt von \texttt{javax.swing.JFrame}}

Hauptfenster des Programms. Verantwortlich für die Initialisierung aller enthaltenen GUI-Elemente.

\textbf{\texttt{public MainWindow()}}\\
Initialisiert das Hauptfenster und die enthaltenen GUI-Elemente (ConsolePanel, EditorPanel, VisualisationPanel, MenuBar, ToolBar).

\textbf{\texttt{public ConsolePanel getConsolePanel()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{ConsolePanel}: Instanz von Klasse für Eingabefeld und Konsole
\end{itemize}
Gibt die Instanz der Klasse für den GUI-Bereich zurück, der das Eingabefeld und die Konsole umfasst.

\textbf{\texttt{public VisualisationPanel getVisualisationPanel()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{VisualisationPanel}: Instanz von Klasse für Visualisierungsbereich
\end{itemize}
Gibt die Instanz der Klasse für den GUI-Bereich zurück, der die angezeigte Visualisierung umfasst.

\textbf{\texttt{public EditorPanel getEditorPanel()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{EditorPanel}: Instanz von Klasse für Editor
\end{itemize}
Gibt die Instanz der Klasse für den GUI-Bereich zurück, der den Editor umfasst.

\subsubsection{Klasse \texttt{MenuBar} erbt von \texttt{javax.swing.JMenuBar}}

Menüleiste des Hauptfensters. Bietet u.a. Funktionen für Dateioperationen (Öffnen, Speichern, Speichern unter...), Programmoperationen (Parsen, Schrittoperationen des Interpreters), Exportoperationen (Visualisierungsexport zu Bildformaten oder TikZ) und Einstellungen (Sprachwahl).

\textbf{\texttt{public MenuBar(MainWindow gui)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{gui}: Instanz des Hauptfensters
\end{itemize}
Initialisiert die Menüleiste mit allen verfügbaren Einträgen und Untermenüs.

\subsubsection{Klasse \texttt{MenuItem} erbt von \texttt{javax.swing.JMenuItem}}

Menü-Element der Menüleiste oder eines Untermenüs. Führt beim Betätigen ein Command des Controllers aus.

\textbf{\texttt{public MenuItem(String textKey, Command command)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen des Menü-Elements
\end{itemize}
Initialisiert ein neues Menü-Element. Dieses erhält seinen Menütext von der LanguageManager-Klasse über den Schlüsselwert \texttt{textKey}. Beim Betätigen des Menü-Elements wird \texttt{command} ausgeführt wird.

\subsubsection{Klasse \texttt{ToolBar} erbt von \texttt{javax.swing.JToolBar}}

Werkzeugleiste des Hauptfensters.

\textbf{\texttt{public ToolBar(MainWindow gui)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{gui}: Instanz des Hauptfensters
\end{itemize}
Initialisiert die Werkzeugleiste und die enthaltenen Schaltflächen.

\subsubsection{Klasse \texttt{VisualisationPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Element, welches die Visualisierung umfasst und Schnittstellen für diese bietet.

\textbf{\texttt{public VisualisationPanel()}}\\
Initialisiert den GUI-Bereich der Visualisierung sowie den VisualisationViewer.

\textbf{\texttt{public void clearVisualisation()}}\\
Leert den Inhalt des VisualisationViewers.

\textbf{\texttt{public void zoom(ZoomType direction)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{direction}: Richtung der Vergrößerung (hinein oder heraus bewegen)
\end{itemize}
Vergrößert oder verkleinert den angezeigen Bildausschnitt des Graphen.

\textbf{\texttt{public void setFromGraph(Graph graph)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{graph}: Der neue Graph, welcher angezeigt werden soll
\end{itemize}
Aktualisiert den angezeigten Graphen.

\subsubsection{Klasse \texttt{VisualisationViewer} erbt von \texttt{org.apache.batik.swing.JSVGCanvas}}

Visualisierungselement für einen generierten Graphen.

\textbf{\texttt{public VisualisationViewer()}}\\
Initialisiert eine leere Visualisierung sowie die Eingabefunktionen der Maus für die Navigation des Graphen.

\textbf{\texttt{public void setFromGraph(Graph graph)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{graph}: Der anzuzeigende Graph
\end{itemize}
Ersetzt den Angezeigten durch den im Parameter gegebenen Graphen.

\textbf{\texttt{public void clear()}}\\
Leert den Anzeigebereich der Visualisierung.

\newpage
\subsection{Paket \texttt{edu.kit.ipd.pp.viper.controller}}

Repräsentation der Controller-Komponente in Kontext des Model-View-Controller Architekturstils. Umfasst Kommandos zur Kapselung von Interaktionen zwischen der View-Komponente und der Model-Komponente.

\subsubsection{Klasse \texttt{LanguageManager} erbt von \texttt{java.util.Observable}}

Verwaltungsstruktur für Übersetzungen. Die Klasse ist nach dem Singleton-Entwurfsmuster modelliert. Alle Texte der GUI werden über einen eindeutigen Schlüsselwert identifiziert. Der LanguageManager bietet zentrale Übersetzungen für diese Schlüsselwerte in Abhängigkeit der gesetzten Sprache. Unterstützte Sprachen sind Deutsch und Englisch.

\textbf{\texttt{private LanguageManager()}}\\
Initialisiert die Datenstrukturen der Übersetzungen. Die anfänglich festgelegte Sprache ist Deutsch.

\textbf{\texttt{public static LanguageManager getInstance()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{LanguageManager}: Instanz des LanguageManagers
\end{itemize}
Gibt eine Instanz des \texttt{LanguageManager}s zurück. Existiert noch keine Instanz, wird diese zuvor über den privaten Konstruktor erstellt.

\textbf{\texttt{public void setLocale(Locale locale)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{locale}: Gewünschte Sprache
\end{itemize}
Setzt die gewünschte Sprache auf \texttt{locale}. Diese Einstellung wird beim Schließen des Programms erhalten. Ein Aufruf dieser Methode hat die Aktualisierung der gesamten GUI zur Folge.

\textbf{\texttt{public String getString(String textKey)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] Returns \texttt{String}: Übersetzung für aktuell gesetzte Sprache
\end{itemize}
Gibt die Übersetzung für den Schlüssel \texttt{key} in der aktuell gesetzten Sprache zurück. Existiert die angeforderte Übersetzung nicht, so wird der Text in Standard-Sprache (Deutsch) zurückgegeben.

\textbf{\texttt{public List<Locale> getSupportedLanguages()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
    \item[-] Returns \texttt{List<Locale>}: Liste mit unterstützten Sprachen
\end{itemize}
Gibt eine Liste mit allen unterstützten Sprachen zurück.

\subsubsection{Klasse \texttt{InterpreterManager}}

Ermöglicht das Parsen von Prolog-Programmen. Verwaltungsstruktur für alle vorhandenen Interpreterzustände. Bietet eine zentrale Referenz auf den aktuellen Zustand. Bietet zusätzlich eine Schnittstelle um auf dem aktuellen Zustand Operationen auszuführen.

\textbf{\texttt{public InterpreterManager()}}\\
Initialisiert eine Instanz des InterpreterManagers. Die anfängliche Liste an Interpretern ist leer.

\textbf{\texttt{public void createNew(String program)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{program}: Inhalt des EditorPanels
\end{itemize}
Parst den Inhalt des Editors. Erstellt den ersten Interpreterzustand.

\textbf{\texttt{public StepResult step()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
    \item[-] Returns \texttt{StepResult}: Ergebnis des ausgeführten Schritts
\end{itemize}
Führt auf dem aktuellen Interpreterzustand die step() Methode auf.

\textbf{\texttt{public void runUntilNextSolution()}}\\
Erstellt einen neuen Thread. Führt in diesem auf dem aktuellen Interpreterzustand wiederholt die step() Methode auf, bis eine Lösung gefunden wurde oder von außen eine boolean-Flag für den Abbruch gesetzt wurde.

\textbf{\texttt{public void cancel()}}\\
Setzt die boolean-Flag für den Thread auf false und bricht somit runUntilNextSolution() Methode ab. 

\textbf{\texttt{public Interpreter getCurrentState()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
    \item[-] Returns \texttt{Interpreter}: Der aktuelle Interpreterzustand
\end{itemize}
Gibt den aktuellen Interpreterzustand aus der internen Liste an Interpreterzuständen zurück.

\textbf{\texttt{public List<Substitution> getSolution()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
    \item[-] Returns \texttt{List<Substitution>}: Eine Liste an Substitutionen
\end{itemize}
Gibt eine Liste mit allen vorhandenen Subtitutionen aus dem aktuellen Interpreterzustand zurück.

\subsubsection{Klasse \texttt{Command}}

Abstrakte Kommando-Klasse für die Kapselung von Programm-Abläufen. Entspricht dem Kommando-Entwurfsmuster.

\textbf{\texttt{protected Command()}}\\
Leerer Konstruktor des Kommandos.

\textbf{\texttt{public abstract void execute()}}\\
Abstrakte Ausführungs-Methode des Befehls. Wird von Unterklassen entsprechend ihrer Funktionalität implementiert.

\subsubsection{Klasse \texttt{CommandNew} erbt von \texttt{Command}}

Kommando zum Anlegen einer neuen Datei im Editor. Der Editor, die Konsole sowie die Visualisierung werden hierbei geleert. Sollten zuvor ungespeicherte Änderungen am Editor-Inhalt gemacht worden sein, wird nachgefragt, ob diese gespeichert werden sollen. Ist eine Referenz auf eine gespeicherte Datei im Editor gesetzt, wird diese am Ende der Ausführung gelöscht. Nach dem Ausführen des Neu-Befehls wird entsprechend beim ersten Speichern die Speichern-unter-Funktion ausgeführt.

\textbf{\texttt{public CommandNew(ConsolePanel console, EditorPanel editor,\\VisualisationPanel visualisation)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandOpen} erbt von \texttt{Command}}

Kommando zum Öffnen einer Datei über einen Öffnen-Dialog. Der Datei-Inhalt wird hierbei in den Editor geladen. Sowohl die Visualisierung als auch die Konsole werden geleert. Bei ungespeicherten Änderungen am Editor-Inhalt vor dem Laden der neuen Datei wird nachgefragt, ob diese gespeichert werden sollen.

\textbf{\texttt{public CommandOpen(ConsolePanel console, EditorPanel editor,\\VisualisationPanel visualisation)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandSave} erbt von \texttt{Command}}

Kommando zum Speichern des Editor-Inhalts auf einem Speichermedium über einen Speichern-Dialog. Fehler oder ein Hinweis auf das erfolgreiche Speichern werden auf der Konsole ausgegeben. Das Kommando umfasst sowohl die Speichern- als auch die Speichern-unter-Funktionalität und unterscheidet diese über einen Enumerations-Parameter.

\textbf{\texttt{public CommandSave(ConsolePanel console, EditorPanel editor,\\SaveType saveAs)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{saveAs}: Speicher-Typ (Speichern oder Speichern unter...)
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors und der Konsole sowie einem Speicher-Typ, der bei der Ausführung zwischen Speichern und Speichern-unter unterscheidet.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandParse} erbt von \texttt{Command}}

Kommando zum Parsen des Editor-Inhalts. Der Editor-Inhalt wird hierbei durch das Parser-Objekt verarbeitet, auftretende Fehler werden über die Konsole ausgegeben, die Visualisierung wird geleert.

\textbf{\texttt{public CommandParse(ConsolePanel console, EditorPanel editor,\\VisualisationPanel visualisation, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Parser und auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandNextStep} erbt von \texttt{Command}}

Kommando zum Ausführen eines Interpreter-Schritts. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem aktuellen Stand der Interpretation angepasst.

\textbf{\texttt{public CommandNextStep(ConsolePanel console,\\VisualisationPanel visualisation, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandPreviousStep} erbt von \texttt{Command}}

Kommando zum Rückgängig-machen eines Interpreter-Schritts. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem aktuellen Stand der Interpretation angepasst.

\textbf{\texttt{public CommandPreviousStep(ConsolePanel console,\\VisualisationPanel visualisation, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandContinue} erbt von \texttt{Command}}

Kommando zum Ausführen von Interpreter-Schritten bis zum Finden der nächsten Lösung. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem Stand der Interpretation beim Finden der Lösung angepasst.

\textbf{\texttt{public CommandContinue(ConsolePanel console,\\VisualisationPanel visualisation, boolean running, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
    \item[-] \texttt{running}: Zustandsvariable, die aussagt, ob der Interpreter läuft
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandCancel} erbt von \texttt{Command}}

Kommando zum Abbrechen des Interpreters beim Suchen der nächsten Lösung.

\textbf{\texttt{public CommandCancel(boolean running, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
    \item[-] \texttt{running}: Zustandsvariable, die aussagt, ob der Interpreter läuft
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit einer Referenz auf einen Prolog-Interpreter.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandToggleLib} erbt von \texttt{Command}}

Kommando zum Aktivieren bzw. Deaktivieren der Standardbibliothek im Parser. Hierbei werden sowohl die Konsole als auch die Visualisierung geleert.

\textbf{\texttt{public CommandToggleLib(ConsolePanel console,\\VisualisationPanel visualisation, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Parser und auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandZoom} erbt von \texttt{Command}}

Kommando zum Zoomen innerhalb der Visualisierung. Dieses Kommando umfasst sowohl das Hinein- als auch das Herauszoomen und unterscheidet diese bei der Ausführung über eine Enumeration.

\textbf{\texttt{public CommandZoom(VisualisationPanel visualisation,\\ZoomType direction)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{direction}: Art des Zooms (herein oder heraus)
\end{itemize}
Initialisiert das Kommando mit einer Referenz auf die Schnittstelle der Visualisierung sowie einem Zoom-Typ.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandSetLang} erbt von \texttt{Command}}

Kommando zum Setzen einer anderen Sprache für die grafische Oberfläche. Die Konsole sowie die Visualisierung werden hierbei geleert.

\textbf{\texttt{public CommandSetLang(ConsolePanel console,\\VisualisationPanel visualisation, Locale lang, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole sowie der zu setzenden Sprache.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandFormat} erbt von \texttt{Command}}

Kommando zum Formatieren des Editor-Inhalts. Nach erfolgreicher Formatierung wird ein Hinweis über die Konsole ausgegeben.

\textbf{\texttt{public CommandFormat(ConsolePanel console, EditorPanel editor)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{editor}: Schnittstelle des Editors
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors und der Konsole.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandExportTikz} erbt von \texttt{Command}}

Kommando zum Exportieren der Visualisierung als TikZ-Quelltext. Fehler oder Hinweise zum erfolgreichen Export werden in der Konsole ausgegeben.

\textbf{\texttt{public CommandExportTikz(ConsolePanel console,\\VisualisationPanel visualisation, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandExportImage} erbt von \texttt{Command}}

Kommando zum Exportieren der Visualisierung als Bild-Datei (PNG oder SVG). Der Dateityp wird über eine Enumeration bei der Ausführung unterschieden. Fehler oder Hinweise zum erfolgreichen Export werden in der Konsole ausgegeben.

\textbf{\texttt{public CommandExportImage(ConsolePanel console,\\VisualisationPanel visualisation, ImageFormat format, InterpreterManager interpreterManager)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{format}: Format der Bild-Datei
	\item[-] \texttt{interpreterManager}: InterpreterManager mit Referenz auf den aktuellen Interpreter
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole sowie dem gewollten Bild-Format.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Enum \texttt{ZoomType}}

Repräsentiert die möglichen Modi für Zoom im angezeigten Bildausschnitt der Visualisierung. Wird von CommandZoom verwendet.

\textbf{\texttt{ZoomType.ZOOM\_IN}}\\
Modus für Vergrößerung des angezeigen Bildausschnitts.

\textbf{\texttt{ZoomType.ZOOM\_OUT}}\\
Modus für Verkleinerung des angezeigen Bildausschnitts.

\subsubsection{Enum \texttt{ImageFormat}}

Repräsentiert Formate für den Bild-Export der angezeigten Visualisierung.

\textbf{\texttt{ImageFormat.SVG}}\\
Bildformat SVG (\enquote{Scalable Vector Graphics}) mit der Dateiendung \texttt{.svg}.

\textbf{\texttt{ImageFormat.PNG}}\\
Bildformat PNG (\enquote{Portable Network Graphics}) mit der Dateiendung \texttt{.png}.

\subsubsection{Enum \texttt{SaveType}}

Gibt an, wie das Speichern eines im Editor eingegebenen Prolog-Programms behandelt werden soll.

\textbf{\texttt{SaveType.SAVE}}\\
Speichert das Prolog-Programm unter bekanntem Namen und Dateipfad ab, die existierende Datei wird dabei überschrieben.

\textbf{\texttt{SaveType.SAVE\_AS}}\\
Speichert das Prolog-Programm unter einem neuen Namen bzw. Dateipfad, das bedeutet dass der Nutzer über einen Speichern-unter Dialog aufgefordert wird, einen neuen Speicherort auszuwählen.

\section{Bibliotheken}

\subsection{Paket \texttt{javax.swing}}
Stellt Komponenten für das Erstellen einer GUI bereit. Das Swing-Paket ist Teil der Java-Standardbibliothek.\\\\Genutzte Datenstrukturen:

\begin{multicols}{2}
\begin{itemize}
	\item Klasse: JFrame
	\item Klasse: JMenu	
	\item Klasse: JMenuBar
	\item Klasse: JMenuItem
	\item Klasse: JToolBar
	\item Klasse: JButton
	\item Klasse: JPanel
	\item Klasse: JTextField
\end{itemize}
\end{multicols}

\subsection{Paket \texttt{java.util}}
Stellt Hilfs-Datenstrukturen bereit. Das Utilities-Paket ist Teil der Java-Standardbibliothek.\\\\Genutzte Datenstrukturen:

\begin{multicols}{2}
\begin{itemize}
	\item Klasse: ListResourceBundle
	\item Klasse: Observable
	\item Interface: Observer
\end{itemize}
\end{multicols}

\subsection{Paket \texttt{org.apache.batik.swing}}

Beinhaltet eine Leinwand mit der es möglich ist, Bilder im SVG-Format anzuzeigen und in diesen zu navigieren. Das Paket stammt aus der Apache Batik Bibliothek, verfügbar unter:\\ \url{https://xmlgraphics.apache.org/batik/}.\\\\Genutzte Datenstrukturen:
\begin{itemize}
	\item Klasse: JSVGCanvas
\end{itemize}

\subsection{Paket \texttt{org.fife.ui.rsyntaxtextarea}}

Beinhaltet ein Textfeld, welches im vgl. zum Textfeld aus dem Swing-Paket zusätzliche Funktionen wie z.B. Code-Faltung (das automatische Umbrechen und Einrücken von Text) unterstützt. Dieses Paket stammt aus der \texttt{RSyntaxTextArea} Bibliothek, verfügbar unter:  \url{https://github.com/bobbylight/RSyntaxTextArea}.\\\\Genutzte Datenstrukturen:
\begin{itemize}
	\item Klasse: RSyntaxArea
\end{itemize}

\subsection{Paket \texttt{guru.nidi.graphviz}}

Beinhaltet Klassen zur Modellierung und grafischen Ausgabe von Graphen. Das Paket stammt aus der \texttt{graphviz-java} Bibliothek, verfügbar unter:\\ \url{https://github.com/nidi3/graphviz-java}.\\\\Genutzte Datenstrukturen:
\begin{itemize}
	\item Klasse: Graph
	\item Klasse: Graphviz
\end{itemize}

\section{Sequenzdiagramme}

\subsection{Initialisierung der grafischen Benutzeroberfläche}

Aufbausequenz der grafischen Oberfläche. Enthält die Initialisierung der Schnellzugriffsleiste und Menüleiste sowie der Panels für die Visualisierung, die Konsole und den Editor mit den zugehörigen Schaltflächen.

\subsection{Öffnen einer Prolog-Datei}

Ablauf der Öffnen-Sequenz einer Prolog-Datei, welche durch die Interaktion mit der grafischen Oberfläche ausgelöst und über ein Kommando abgewickelt wird. Das Öffnen leert hierbei automatisch auch die Visualisierung sowie die Konsole.

\subsection{Sprachwechsel}

Ablauf des Sprachwechsels. Hierbei wird die aktuell gewählte Sprache zu einer anderen implementierten Sprache geändert und die grafische Oberfläche entsprechend aktualisiert.

\subsection{Interpretationsschritt}

Ablauf der Ausführung eines allgemeinen Interpretationsschritts.

\subsection{Unifikation}

Ablauf der Unifikation zweier Funktoren innerhalb eines Interpretationsschritts.

\subsection{Visualisierung}

Ablauf der Visualisierung nach einem abgeschlossenen Interpretationsschritt. 

\subsection{Graph}

Ablauf der Generierung des Graphen aus dem aktuellen Interpreterzustand in der Visualisierung.

\section{Zustandsdiagramm}

Veranschaulichung der möglichen Zustände und Zustandsübergänge für das Parsen und Interpretieren eines Prolog-Programmes sowie die Ausgabe der Visualisierung.

\appendix

\section{Anhang}

\subsection{Klassendiagramm}

\end{document}
