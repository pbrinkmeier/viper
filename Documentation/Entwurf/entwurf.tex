\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER Interactive Prolog Education Runtime}
\subtitle{Entwurf}
\author{Paul Brinkmeier, Lukas Brocke, Jannik Koch, Aaron Maier, Christian Oder}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{dirtree}
\hypersetup{
	pdftitle={Entwurf},
}

\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\lstset{basicstyle=\ttfamily,breaklines=true}

% Don't strech across whole page
\raggedbottom

% Start new page with each section
\usepackage{sectsty}
\sectionfont{\clearpage}

\begin{document}
\maketitle

\section{Einleitung}

VIPER wird nach dem \enquote{Model-View-Controller}-Architekturstil entworfen.

Die Model"=Komponente kapselt interne Datenstrukturen, welche wiederum von der View"=Komponente (in diesem Fall einer GUI für Desktop"=Anwendungen) graphisch dargestellt werden. Dazu gehören u.a. der Inhalt des Editors oder des Konsolen"=Ausgabefensters. Alle Komponenten werden mit Java implementiert. Für die View"=Komponente wird spezifisch die GUI-Bibliothek Swing genutzt. Die Model"=Komponente funktioniert unabhängig von der View-Komponente.

Interaktionen mit der Software durch die View"=Komponente werden über die Controller"=Komponente verarbeitet. Dadurch entstehende Änderungen, bspw. eine Eingabe in den Editor, nehmen wiederum Einfluss auf die internen Datenstrukturen in der Model"=Komponente und damit auf die View"=Komponente. Die Paketstruktur orientiert sich an den vom Architekturstil festgelegten Unterteilungen:\\

\begin{center}
	\begin{minipage}{0.4\textwidth}%
		\dirtree{%
			.1 edu.kit.ipd.pp.viper.
			.2 model.
			.3 ast.
			.3 parser.
			.3 interpreter.
			.3 visualisation.
			.2 controller.
			.2 view.
		}
	\end{minipage}
\end{center}

Das Model"=Paket kapselt die genannte Model"=Komponente. Innerhalb dieses Pakets existieren Unterpakete für die Implementierung des abstrakten Syntaxbaumes (AST), des Prolog"=Parsers und "=Interpreters sowie der Visualisierung. Weiter existieren eigene Pakete für die Implementierung der View- und Controller"=Komponente. Der Inhalt des Visualisierungs"=Unterpakets beschäftigt sich explizit mit der Generierung der Daten für die Visualisierung, die eigentliche visuelle Darstellung erfolgt in der View-Komponente.


\section{Klassenbeschreibungen}

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.view}}

\subsubsection{Klasse \texttt{Button} erbt von \texttt{javax.swing.JButton}}

Initialisiert eine neues Schaltflächen-Element für die GUI. Beim Betätigen der Schaltfläche wird ein entsprechender Befehl über den Controller ausgeführt.

\textbf{\texttt{public Button(String textKey, Command command)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen der Schaltfläche
\end{itemize}
Initialisiert die Schaltfläche mit dem auszuführenden Befehl. Weiterhin wird der Tooltip der Schaltfläche durch den übergebenen Schlüssel aus dem LanguageManager geholt und für die Schaltfläche gesetzt.

\subsubsection{Klasse \texttt{ConsoleInputField} erbt von \texttt{javax.swing.JTextField}}

Eingabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Ausgabefeld für den Nutzer editierbar und dient der Eingabe von Prolog-Abfragen. Das Eingabefeld ist weiterhin sperrbar, um Eingaben durch den Nutzer zu verhindern, bis es wieder freigegeben wurde.

\textbf{\texttt{public ConsoleInputField()}}\\
Initialisiert ein leeres, editierbares Textfeld mit einer einzelnen Zeile.

\textbf{\texttt{public String getText()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Inhalt des Eingabefeldes
\end{itemize}
Gibt den aktuellen Inhalt des Eingabefeldes zurück.

\textbf{\texttt{public void clear()}}\\
Leert das Eingabefeld.

\textbf{\texttt{public void lock()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben durch den Nutzer möglich sind.

\textbf{\texttt{public void unlock()}}\\
Gibt das Eingabefeld frei, sodass Eingaben durch den Nutzer möglich sind. Das Eingabefeld wird vor der Freigabe geleert.

\subsubsection{Klasse \texttt{ConsoleOutputArea} erbt von \texttt{javax.swing.JTextField}}

Ausgabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Eingabefeld für den Nutzer ausschließlich lesbar und dient der Ausgabe von Informationen über den Stand des Programmes, Fehlermeldungen oder den Ergebnissen von Prolog-Abfragen. Einzelne Zeilen der Ausgabe können zur besseren visuellen Rückmeldung eingefärbt werden. Ausgaben werden am Ende der Zeile umgebrochen. Das Textfeld erlaubt das Scrollen durch alle ausgegebenen Zeilen, sollten diese die Anzahl gleichzeitig sichtbarer Zeilen überschreiten.

\textbf{\texttt{public ConsoleOutputArea()}}\\
Initialisiert ein leeres, vom Nutzer nur lesbares Textfeld mit mehreren Zeilen.

\textbf{\texttt{public void printLine(String line, Color color)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{line}: Der anzuzeigende Text
	\item[-] \texttt{color}: Gewünschte Farbe für den gesamten Text
\end{itemize}
Gibt eine neue Zeile mit Text \texttt{line} in der Farbe \texttt{color} im Textfeld aus. Sollte bereits die unterste Zeile erreicht werden, werden alle Zeilen darüber nach oben geschoben und die neue Zeile unten angefügt.

\textbf{\texttt{public void clear()}}\\
Leert den Inhalt des Textfelds.

\subsubsection{Klasse \texttt{ConsolePanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Panel, welches das Eingabe- und Ausgabefeld umschließt. Dieses Element bildet die Konsole und leitet Befehle an die einzelnen Konsolen-Elemente an diese weiter.

\textbf{\texttt{public ConsolePanel()}}\\
Initialisiert das Eingabe- und Ausgabefeld.

\textbf{\texttt{public void clearAll()}}\\
Leert sowohl das Eingabe- als auch das Ausgabefeld.

\textbf{\texttt{public void clearOutputArea()}}\\
Leert ausschließlich den Inhalt des Ausgabefelds.

\textbf{\texttt{public void clearInputField()}}\\
Leert ausschließlich den Inhalt des Eingabefelds.

\textbf{\texttt{public void lockInput()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben mehr möglich sind.

\textbf{\texttt{public void unlockInput()}}\\
Gibt das Eingabefeld frei, sodass Eingaben möglich sind. Der Inhalt wird bei der Freigabe geleert.

\subsubsection{Klasse \texttt{EditorPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Panel, welches das externe Editor-Element \texttt{RSyntaxTextArea} umschließt. Bietet Schnittstellen zum Setzen und Erhalten des Editor-Inhalts.

\textbf{\texttt{public EditorPanel()}}\\
Initialisiert einen leeren, editierbaren Editor und konfiguriert ihn für Prolog-Quelltext.

\textbf{\texttt{public String getSourceText()}}\\
Gibt den aktuellen Inhalt des Editors zurück.

\textbf{\texttt{public void setSourceText(String text)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{text}: Gewünschter Text
	\item[-] Returns \texttt{String}: Der aktuelle Editor-Inhalt
\end{itemize}
Setzt den Inhalt des Editors. Der vorherige Inhalt wird dabei verworfen.

\subsubsection{Klasse \texttt{LanguageManager} erbt von \texttt{Observable}}

Verwaltungsstruktur für Übersetzungen. Die Klasse ist nach dem Singleton-Entwurfsmuster modelliert. Alle Texte der GUI werden über einen eindeutigen Schlüsselwert identifiziert. Der LanguageManager bietet zentrale Übersetzungen für diese Schlüsselwerte in Abhängigkeit der gesetzten Sprache. Unterstützte Sprachen sind Deutsch und Englisch.

\textbf{\texttt{private LanguageManager()}}\\
Initialisiert die Datenstrukturen der Übersetzungen. Die anfänglich festgelegte Sprache ist Englisch.

\textbf{\texttt{public static LanguageManager getInstance()}}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{LanguageManager}: Instanz des LanguageManagers
\end{itemize}
Gibt eine Instanz des \texttt{LanguageManager}s zurück. Ist noch keine Instanz existent, wird diese über den privaten Konstruktor erstellt. Sobald eine Instanz existiert, wird diese bei weiteren Aufrufen zurückgegeben.

\textbf{\texttt{public void setLocale(Locale locale)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] throws \texttt{UnsupportedLocaleException}
	\item[-] \texttt{locale}: Gewünschte Sprache
\end{itemize}
Setzt die gewünschte Sprache auf \texttt{locale}. Diese Einstellung wird beim Schließen des Programms erhalten. Ein Aufruf dieser Methode hat die Aktualisierung der gesamten GUI zur Folge. Ist die gewünschte Sprache nicht unterstützt, so wird eine passende Exception geworfen.

\textbf{\texttt{public static String getString(String textKey)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] Returns \texttt{String}: Übersetzung für aktuell gesetzte Sprache
\end{itemize}
Gibt die Übersetzung für den Schlüssel \texttt{key} in der aktuell gesetzten Sprache zurück.

\subsubsection{Klasse \texttt{MainWindow} erbt von \texttt{javax.swing.JFrame}}

Hauptfenster des Programms. Verantwortlich für die Initialisierung aller enthaltenen GUI-Elemente.

\textbf{\texttt{public MainWindow()}}\\
Initialisiert das Hauptfenster und die enthaltenen GUI-Elemente (ConsolePanel, EditorPanel, VisualisationPanel, MenuBar, ToolBar).

\subsubsection{Klasse \texttt{MenuBar} erbt von \texttt{javax.swing.JMenuBar}}

Menüleiste des Hauptfensters. Bietet u.a. Funktionen für Dateioperationen (Öffnen, Speichern, Speichern unter...), Programmoperationen (Parsen, Schrittoperationen des Interpreters), Exportoperationen (Visualisierungsexport zu Bildformaten oder TikZ) und Einstellungen (Sprachwahl).

\textbf{\texttt{public MenuBar()}}\\
Initialisiert die Menüleiste mit allen verfügbaren Einträgen und Untermenüs.

\subsubsection{Klasse \texttt{MenuItem} erbt von \texttt{javax.swing.JMenuItem}}

Menü-Element der Menüleiste oder eines Untermenüs. Führt beim Betätigen ein Command des Controllers aus.

\textbf{\texttt{public MenuItem(String textKey, Command command)}}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen des Menü-Elements
\end{itemize}
Initialisiert ein neues Menü-Element. Dieses erhält seinen Menütext von der LanguageManager-Klasse über den Schlüsselwert \texttt{textKey}. Weiter wird beim Betätigen des Menü-Elements \texttt{command} ausgeführt wird.

\subsubsection{Klasse \texttt{Observable}}

Die Observer-Klasse richtet einer erbenden Unterklasse eine Schnittstelle ein, mit der andere Klassen sich bei dieser registrieren können. Bei Ereignissen (bspw. dem Umstellen der Sprache) werden diese registrierten Klassen aufgerufen, wodurch z.B das automatische Aktualisieren der Texte beim Sprachwechsel vereinfacht wird.

\textbf{\texttt{public Observable()}}\\
Erstellt eine neue Instanz.

\textbf{\texttt{public void addListener(Observer listener)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{listener}: Neuer Beobachter, der benachrichtigt werden kann.
\end{itemize}
Registriert einen neuen Beobachter.

\textbf{\texttt{public void notifyListeners()}}\\
Benachrichtigt alle vorher durch \texttt{addListener()} hinzugefügte Beobachter.

\subsubsection{Interface \texttt{Observer}}

Schnittstelle für Klassen, die bei einer Spezialisierung der Observable-Klasse registrierbar sein sollen.

\textbf{\texttt{public void update()}}\\
Methode, welche durch die Spezialisierung der Observable-Klasse im Falle eines Ereignisses aufgerufen wird.

\subsubsection{Klasse \texttt{ToolBar} erbt von \texttt{javax.swing.JToolBar}}

Werkzeugleiste des Hauptfensters.

\textbf{\texttt{public ToolBar()}}\\
Initialisiert die Werkzeugleiste und die enthaltenen Schaltflächen.

\subsubsection{Klasse \texttt{VisualisationPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Element, welches die Visualisierung umspannt und Schnittstellen für diese bietet.

\textbf{\texttt{public VisualisationPanel()}}\\
Initialisiert das GUI-Panel der Visualisierung und den VisualisationViewer.

\textbf{\texttt{public void clearVisualisation()}}\\
Leert den Inhalt des VisualisationViewers.

\subsubsection{Klasse \texttt{VisualisationViewer} erbt von \texttt{org.apache.batik.swing.JSVGCanvas}}

Visualisierungselement für einen generierten Graphen.

\textbf{\texttt{public VisualisationViewer()}}\\
Initialisiert eine leere Visualisierung sowie die Eingabefunktionen der Maus für die Navigation des Graphen.

\textbf{\texttt{public void updateGraph(String graph)}}
\begin{itemize}[noitemsep]
	\item[-] \texttt{graph}: Der anzuzeigende Graph
\end{itemize}
Ersetzt den angezeigten Graph durch den im Parameter gegebenen Graph.

\textbf{\texttt{public void clear()}}\\
Leert den Anzeigebereich der Visualisierung.

\subsubsection{Klasse \texttt{UnsupportedLocaleException} erbt von \texttt{java.lang.Exception}}
Exception-Klasse für den Versuch, eine nicht-unterstützte Sprache im LanguageManager zu setzen.

\textbf{\texttt{public String getLocalizedMessage()}}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Lokalisierte Fehlermeldung
\end{itemize}
Gibt den Fehlertext der Exception als lokalisierten (an die gesetzte Sprache angepassten) String zurück. Die gewählte Sprache des Fehlertexts entspricht der Sprache vor dem versuchten Wechsel, der die Exception ausgelöst hat.

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.controller}}

\subsubsection{Klasse \texttt{Command}}
Abstrakte Kommando-Klasse für die Kapselung von Programm-Abläufen. Entspricht dem Kommando-Entwurfsmuster.

\textbf{\texttt{protected Command()}}\\
Leerer Konstruktor des Kommandos.

\textbf{\texttt{public abstract void execute()}}\\
Abstrakte Ausführungs-Methode des Befehls. Wird von Unterklassen entsprechend ihrer Funktionalität implementiert.

\subsubsection{Klasse \texttt{CommandNew} erbt von \texttt{Command}}
Kommando zum Anlegen einer neuen Datei im Editor. Der Editor, die Konsole sowie die Visualisierung werden hierbei geleert. Sollten zuvor ungespeicherte Änderungen am Editor-Inhalt gemacht worden sein, wird nachgefragt, ob diese gespeichert werden sollen. Ist eine Referenz auf eine gespeicherte Datei im Editor gesetzt, wird diese am Ende der Ausführung gelöscht. Nach dem Ausführen des Neu-Befehls wird entsprechend beim ersten Speichern die Speichern-unter-Funktion ausgeführt.

\textbf{\texttt{public CommandNew(editor: EditorPanel, console: ConsolePanel,\\visualisation: VisualisationPanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandOpen} erbt von \texttt{Command}}
Kommando zum Öffnen einer Datei über einen Öffnen-Dialog. Der Datei-Inhalt wird hierbei in den Editor geladen. Sowohl die Visualisierung als auch die Konsole werden geleert. Bei ungespeicherten Änderungen am Editor-Inhalt vor dem Laden der neuen Datei wird nachgefragt, ob diese gespeichert werden sollen.

\textbf{\texttt{public CommandOpen(editor: EditorPanel, console: ConsolePanel,\\visualisation: VisualisationPanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandSave} erbt von \texttt{Command}}
Kommando zum Speichern des Editor-Inhalts auf einem Speichermedium über einen Speichern-Dialog. Fehler oder ein Hinweis auf das erfolgreiche Speichern werden auf der Konsole ausgegeben. Das Kommando umfasst sowohl die Speichern- als auch die Speichern-unter-Funktionalität und unterscheidet diese über einen Enumerations-Parameter.

\textbf{\texttt{public CommandSave(editor: EditorPanel, console: ConsolePanel,\\saveAs: SaveType)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{saveAs}: Speicher-Typ (Speichern oder Speichern unter...)
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors und der Konsole sowie einem Speicher-Typ, der bei der Ausführung zwischen Speichern und Speichern-unter unterscheidet.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandParse} erbt von \texttt{Command}}
Kommando zum Parsen des Editor-Inhalts. Der Editor-Inhalt wird hierbei durch das Parser-Objekt verarbeitet, auftretende Fehler werden über die Konsole ausgegeben, die Visualisierung wird geleert.

\textbf{\texttt{public CommandParse(parser: PrologParser, editor: EditorPanel,\\console: ConsolePanel, visualisation: VisualisationPanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{parser}: Parser für den Programmcode
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Parser und auf die Schnittstellen des Editors, der Konsole und der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandNextStep} erbt von \texttt{Command}}
Kommando zum Ausführen eines Interpreter-Schritts. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem aktuellen Stand der Interpretation angepasst.

\textbf{\texttt{public CommandNextStep(interpreter: Interpreter,\\console: ConsolePanel, visualisation: Visualisation)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{interpreter}: Interpreter, der den Schritt ausführen soll
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandPreviousStep} erbt von \texttt{Command}}
Kommando zum Rückgängig-machen eines Interpreter-Schritts. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem aktuellen Stand der Interpretation angepasst.

\textbf{\texttt{public CommandPreviousStep(interpreter: Interpreter,\\console: ConsolePanel, visualisation: Visualisation)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{interpreter}: Interpreter, der den Schritt ausführen soll
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandContinue} erbt von \texttt{Command}}
Kommando zum Ausführen von Interpreter-Schritten bis zum Finden der nächsten Lösung. Ausgaben beim Finden einer Lösung werden über die Konsole dargestellt. Die Visualisierung wird entsprechend dem Stand der Interpretation beim Finden der Lösung angepasst.

\textbf{\texttt{public CommandContinue(interpreter: Interpreter,\\console: ConsolePanel, visualisation: Visualisation)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{interpreter}: Interpreter, der die Schritte ausführen soll
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Interpreter sowie auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandCancel} erbt von \texttt{Command}}
Kommando zum Abbrechen des Interpreters beim Suchen der nächsten Lösung.

\textbf{\texttt{public CommandCancel(interpreter: Interpreter}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{interpreter}: Interpreter, der die Schritte ausführen soll
\end{itemize}
Initialisiert das Kommando mit einer Referenz auf einen Prolog-Interpreter.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandToggleLib} erbt von \texttt{Command}}
Kommando zum Aktivieren bzw. Deaktivieren der Standardbibliothek im Parser. Hierbei werden sowohl die Konsole als auch die Visualisierung geleert.

\textbf{\texttt{public CommandToggleLib(parser: PrologParser,\\console: ConsolePanel, visualisation: Visualisation)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{parser}: Parser, bei welchem die Standardbibliothek (de)aktiviert werden soll
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf einen Prolog-Parser und auf die Schnittstellen der Konsole sowie der Visualisierung.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandZoom} erbt von \texttt{Command}}
Kommando zum Zoomen innerhalb der Visualisierung. Dieses Kommando umfasst sowohl das Hinein- als auch das Herauszoomen und unterscheidet diese bei der Ausführung über eine Enumeration.

\textbf{\texttt{public CommandZoom(visualisation: Visualisation,\\direction: ZoomType)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{direction}: Art des Zooms (herein oder heraus)
\end{itemize}
Initialisiert das Kommando mit einer Referenz auf die Schnittstelle der Visualisierung sowie einem Zoom-Typ.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandSetLang} erbt von \texttt{Command}}
Kommando zum Setzen einer anderen Sprache für die grafische Oberfläche. Die Konsole sowie die Visualisierung werden hierbei geleert.

\textbf{\texttt{public CommandSetLang(lang: Locale, console: ConsolePanel,\\visualisation: VisualisationPanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{lang}: Zu setzende Sprache
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole sowie der zu setzenden Sprache.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandFormat} erbt von \texttt{Command}}
Kommando zum Formatieren des Editor-Inhalts. Nach erfolgreicher Formatierung wird ein Hinweis über die Konsole ausgegeben.

\textbf{\texttt{public CommandFormat(editor: EditorPanel, console: ConsolePanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{editor}: Schnittstelle des Editors
	\item[-] \texttt{console}: Schnittstelle der Konsole
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen des Editors und der Konsole.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandExportTikz} erbt von \texttt{Command}}
Kommando zum Exportieren der Visualisierung als TikZ-Quelltext. Fehler oder Hinweise zum erfolgreichen Export werden in der Konsole ausgegeben.

\textbf{\texttt{public CommandExportTikz(visualisation: VisualisationPanel,\\console: ConsolePanel)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{console}: Schnittstelle der Konsole
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\subsubsection{Klasse \texttt{CommandExportImage} erbt von \texttt{Command}}
Kommando zum Exportieren der Visualisierung als Bild-Datei (PNG oder SVG). Der Dateityp wird über eine Enumeration bei der Ausführung unterschieden. Fehler oder Hinweise zum erfolgreichen Export werden in der Konsole ausgegeben.

\textbf{\texttt{public CommandExportImage(visualisation: VisualisationPanel,\\console: ConsolePanel, format: ImageFormat)}}\\
\begin{itemize}[noitemsep]
	\item[-] \texttt{visualisation}: Schnittstelle der Visualisierung
	\item[-] \texttt{console}: Schnittstelle der Konsole
	\item[-] \texttt{format}: Format der Bild-Datei
\end{itemize}
Initialisiert das Kommando mit Referenzen auf die Schnittstellen der Visualisierung und der Konsole sowie dem gewollten Bild-Format.

\textbf{\texttt{public void execute()}}\\
Führt das beschriebene Kommando aus.

\section{Ablaufdiagramme}

\appendix

\section{Anhang}

\subsection{Klassendiagramm}

\end{document}
