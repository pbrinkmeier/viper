\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER Interactive Prolog Education Runtime}
\subtitle{Entwurf}
\author{Paul Brinkmeier, Lukas Brocke, Jannik Koch, Aaron Maier, Christian Oder}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\usepackage{enumitem}
\hypersetup{
	pdftitle={Entwurf},
}

\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\lstset{basicstyle=\ttfamily,breaklines=true}

% Don't strech across whole page
\raggedbottom

% Start new page with each section
\usepackage{sectsty}
\sectionfont{\clearpage}

\begin{document}
\maketitle

\section{Einleitung}

\section{Klassenbeschreibungen}

\subsection{Paket \texttt{edu.kit.ipd.pp.viper.view}}

\subsubsection{Klasse \texttt{Button} erbt von \texttt{javax.swing.JButton}}

Initialisiert eine neues Schaltflächen-Element für die GUI. Beim Betätigen der Schaltfläche wird ein entsprechender Befehl über den Controller ausgeführt.

\textbf{\texttt{public Button(String textKey, Command command)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen der Schaltfläche
\end{itemize}
Initialisiert die Schaltfläche mit dem auszuführenden Befehl. Weiterhin wird der Tooltip der Schaltfläche durch den übergebenen Schlüssel aus dem LanguageManager geholt und für die Schaltfläche gesetzt.

\subsubsection{Klasse \texttt{ConsoleInputField} erbt von \texttt{javax.swing.JTextField}}

Eingabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Ausgabefeld für den Nutzer schreibbar und dient der Eingabe von Prolog-Abfragen. Das Eingabefeld ist weiterhin sperrbar, um Eingaben durch den Nutzer zu verhindern, bis es wieder freigegeben wurde.

\textbf{\texttt{public ConsoleInputField()}}\\
Initialisiert ein leeres, schreibbares Textfeld mit einer einzelnen Zeile.

\textbf{\texttt{public String getText()}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{String}: Inhalt des Eingabefeldes
\end{itemize}
Gibt den aktuellen Inhalt des Eingabefeldes zurück.

\textbf{\texttt{public void clear()}}\\
Leert das Eingabefeld.

\textbf{\texttt{public void lock()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben durch den Nutzer möglich sind.

\textbf{\texttt{public void unlock()}}\\
Gibt das Eingabefeld frei, sodass Eingaben durch den Nutzer möglich sind. Das Eingabefeld wird vor der Freigabe geleert.

\subsubsection{Klasse \texttt{ConsoleOutputArea} erbt von \texttt{javax.swing.JTextField}}

Ausgabefeld der Konsole. Dieses Textfeld ist im Gegensatz zum Eingabefeld für den Nutzer ausschließlich lesbar und dient der Ausgabe von Informationen über den Stand des Programmes, Fehlermeldungen oder den Ergebnissen von Prolog-Abfragen. Einzelne Zeilen der Ausgabe können zur besseren visuellen Rückmeldung eingefärbt werden. Ausgaben werden am Ende der Zeile umgebrochen. Das Textfeld erlaubt das Scrollen durch alle ausgegebenen Zeilen, sollten diese die Anzahl gleichzeitig anzeigbarer Zeilen überschreiten.

\textbf{\texttt{public ConsoleOutputArea()}}\\
Initialisiert ein leeres, vom Nutzer nur lesbares Textfeld mit mehreren Zeilen.

\textbf{\texttt{public void printLine(String line, Color color)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{line}: Der anzuzeigende Text
	\item[-] \texttt{color}: Gewünschte Farbe für den gesamten Text
\end{itemize}
Gibt eine neue Zeile mit Text \texttt{line} in der Farbe \texttt{color} im Textfeld aus. Sollte bereits die unterste Zeile erreicht werden, werden alle Zeilen darüber nach oben geschoben und die neue Zeile unten angefügt.

\textbf{\texttt{public void clear()}}\\
Leert den Inhalt des Textfelds.

\subsubsection{Klasse \texttt{ConsolePanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Panel, welches das Eingabe- und Ausgabefeld umschließt. Dieses Element bildet die Konsole und leitet Befehle an die einzelnen Konsolen-Elemente an diese weiter.

\textbf{\texttt{public ConsolePanel()}}\\
Initialisiert das Eingabe- und Ausgabefeld.

\textbf{\texttt{public void clearAll()}}\\
Leert sowohl das Eingabe- als auch das Ausgabefeld.

\textbf{\texttt{public void clearOutputArea()}}\\
Leert ausschließlich den Inhalt des Ausgabefelds.

\textbf{\texttt{public void clearInputField()}}\\
Leert ausschließllich den Inhalt des Eingabefelds.

\textbf{\texttt{public void lockInput()}}\\
Sperrt das Eingabefeld, sodass keine Eingaben mehr möglich sind.

\textbf{\texttt{public void unlockInput()}}\\
Gibt das Eingabefeld frei, sodass Eingben möglich sind. Der Inhalt wird bei der Freigabe geleert.

\subsubsection{Klasse \texttt{EditorPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Panel, welches das externe Editor-Element \texttt{org.fife.ui.rsyntaxtextarea.RSyntaxTextArea} umschließt. Bietet Schnittstellen zum Setzen und Erhalten des Editor-Inhalts.

\textbf{\texttt{public EditorPanel()}}\\
Initialisiert einen leeren, schreibbaren Editor und konfiguriert ihn für Prolog-Quelltext.

\textbf{\texttt{public String getSourceText()}}\\
Gibt den aktuellen Inhalt des Editors zurück.

\textbf{\texttt{public void setSourceText(String text)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{text}: Gewünschter Text
	\item[-] Returns \texttt{String}: Der aktuelle Editor-Inhalt
\end{itemize}
Setzt den Inhalt des Editors. Der vorherige Inhalt wird dabei verworfen.

\subsubsection{Klasse \texttt{LanguageManager} erbt von \texttt{Observable}}

Verwaltungsstruktur für Übersetzungen. Die Klasse ist nach dem Singleton-Entwurfsmuster modelliert. Alle Texte der GUI werden über einen eindeutigen Schlüsselwert identifiziert. Der LanguageManager bietet zentrale Übersetzungen für diese Schlüsselwerte in Abhängigkeit der gesetzten Sprache. Unterstützte Sprachen sind Deutsch und Englisch.

\textbf{\texttt{private LanguageManager()}}\\
Initialisiert die Datenstrukturen der Übersetzungen. Die anfänglich festgelegte Sprache ist Englisch.

\textbf{\texttt{public static LanguageManager getInstance()}}
\begin{itemize}[noitemsep]
	\item[-] Returns \texttt{LanguageManager}: Instanz des LanguageManagers
\end{itemize}
Gibt eine Instanz des \texttt{LanguageManager}s zurück. Ist noch keine Instanz existent, wird diese über den privaten Konstruktor erstellt. Sobald eine Instanz existiert, wird diese bei weiteren Aufrufen zurückgegeben.

\textbf{\texttt{public void setLocale(Locale locale)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{locale}: Gewünschte Sprache
\end{itemize}
Setzt die gewünschte Sprache auf \texttt{locale}. Diese Einstellung wird beim Schließen des Programms erhalten. Ein Aufruf dieser Methode hat die Aktualisierung der gesamten GUI zur Folge.\\
Ist die gewünschte Sprache nicht unterstützt, so wird eine \texttt{UnsupportedLocaleException} geworfen.

\textbf{\texttt{public static String getString(String textKey)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] Returns \texttt{String}: Übersetzung für aktuell gesetzte Sprache
\end{itemize}
Gibt die Übersetzung für den Schlüssel \texttt{key} in der aktuell gesetzten Sprache zurück.

\subsubsection{Klasse \texttt{MainWindow} erbt von \texttt{javax.swing.JFrame}}

Hauptfenster des Programms. Verantwortlich für die Initialisierung aller enthaltenen GUI-Elemente.

\textbf{\texttt{public MainWindow()}}\\
Initialisiert das Hauptfenster und die enthaltenen GUI-Elemente (ConsolePanel, EditorPanel, VisualizationPanel, MenuBar, ToolBar).

\subsubsection{Klasse \texttt{MenuBar} erbt von \texttt{javax.swing.JMenuBar}}

Menüleiste des Hauptfensters. Bietet u.a. Funktionen für Dateioperationen (Öffnen, Speichern, Speichern unter...), Programmoperationen (Parsen, Schrittoperationen des Interpreters), Exportoperationen (Visualisierungsexport zu Bildformaten oder TikZ) und Einstellungen (Sprachwahl).

\textbf{\texttt{public MenuBar()}}\\
Initialisiert die Menüleiste mit allen verfügbaren Einträgen und Untermenüs.

\subsubsection{Klasse \texttt{MenuItem} erbt von \texttt{javax.swing.JMenuItem}}

Menü-Element der Menüleiste oder eines Untermenüs. Führt beim Betätigen ein Command des Controllers aus.

\textbf{\texttt{public MenuItem(String textKey, Command command)}}
\begin{itemize}[noitemsep]
	\item[-] \texttt{textKey}: Sprach-Schlüssel für die angeforderte Übersetzung
	\item[-] \texttt{command}: Auszuführender Befehl beim Betätigen des Menü-Elements
\end{itemize}
Initialisiert ein neues Menü-Element. Dieses erhält seinen Menütext von der LanguageManager-Klasse über den Schlüsselwert \texttt{textKey}. Weiter wird beim Betätigen des Menü-Elements \texttt{command} ausgeführt wird.

\subsubsection{Klasse \texttt{Observable}}

Die Observer-Klasse richtet einer erbenden Unterklasse eine Schnittstelle ein, mit der andere Klassen sich bei dieser registrieren können. Bei Ereignissen (bspw. dem Umstellen der Sprache) werden diese registrierten Klassen aufgerufen, wodurch z.B das automatische Aktualisieren der Texte beim Sprachwechsel vereinfacht wird.

\textbf{\texttt{public Observable()}}\\
Erstellt eine neue Instanz.

\textbf{\texttt{public void addListener(Observer listener)}}
\setlist{nolistsep}
\begin{itemize}[noitemsep]
	\item[-] \texttt{listener}: Neuer Beobachter, der benachrichtigt werden kann.
\end{itemize}
Registriert einen neuen Beobachter.

\textbf{\texttt{public void notifyListeners()}}\\
Benachrichtigt alle vorher durch \texttt{addListener()} hinzugefügte Beobachter.

\subsubsection{Interface \texttt{Observer}}

Schnittstelle für Klassen, die bei einer Spezialisierung der Observable-Klasse registrierbar sein sollen.

\textbf{\texttt{public void update()}}\\
Methode, welche durch die Spezialisierung der Observable-Klasse im Falle eines Ereignisses aufgerufen wird.

\subsubsection{Klasse \texttt{ToolBar} erbt von \texttt{javax.swing.JToolBar}}

Werkzeugleiste des Hauptfensters.

\textbf{\texttt{public ToolBar()}}\\
Initialisiert die Werkzeugleiste und die enthaltenen Schaltflächen.

\subsubsection{Klasse \texttt{VisualisationPanel} erbt von \texttt{javax.swing.JPanel}}

GUI-Element, welches die Visualisierung umspannt und Schnittstellen für diese bietet.

\textbf{\texttt{public VisualisationPanel()}}\\
Initialisiert das GUI-Panel der Visualisierung und den VisualisationViewer.

\subsubsection{Klasse \texttt{VisualisationViewer} erbt von \texttt{org.apache.batik.swing.JSVGCanvas}}

Visualisierungselement für einen generierten Graphen.

\textbf{\texttt{public VisualisationViewer()}}\\
Initialisiert eine leere Visualisierung sowie die Eingabefunktionen der Maus für die Navigation des Graphen.

\textbf{\texttt{public void updateGraph(String graph)}}
\begin{itemize}[noitemsep]
	\item[-] \texttt{graph}: Der anzuzeigende Graph
\end{itemize}
Ersetzt den angezeigten Graph durch den im Parameter gegebenen Graph.

\section{Ablaufdiagramme}

\appendix

\section{Anhang}

\subsection{Klassendiagramm}

\end{document}
