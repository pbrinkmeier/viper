\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER: Viper Interactive Prolog Education Runtime}
\author{Paul Brinkmeier, Lukas Brocke, Christian Oder, Aaron Maier, Jannik Koch}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\usepackage{pflichtenheft}

\lstset{basicstyle=\ttfamily,breaklines=true}

\begin{document}
\maketitle

\section{Einleitung}

Prolog ist eine logische Programmiersprache die ein deklaratives Programmieren ermöglicht.

Das Grundprinzip von Prolog operiert auf einer Wissensdatenbank, deren Einträge sich Fakten und Regeln nennen.

\begin{lstlisting}
father(homer, bart).
father(abe, homer).
\end{lstlisting}

So gilt, dass Homer der Vater von Bart ist und Abe der Vater von Homer.

Dabei existiert keine Semantik.

\begin{lstlisting}
x(y, z).
a(b, c).
\end{lstlisting}

Ist eine ebenso legitime Definition.

Für eine Abfrage erhalten wir folgende Ergebnisse:

\begin{lstlisting}
?- father(homer, bart).
yes .
?- father(bart, abe).
no .
\end{lstlisting}

Nun ist es möglich Relationen, basierend auf Fakten, einzuführen. Setzen wir also Großvater für alle Väter von Vätern indem wir Variablen benutzen. Diese beginnen mit Großbuchstaben, Funktoren und Atome mit Kleinbuchstaben.

\begin{lstlisting}
grandfather(X, Y) :- father(X, Z), father(Z, Y).
\end{lstlisting}

Selbiges ist möglich für Abfragen.

\begin{lstlisting}
?- father(X, bart).
X = homer .
?- father(X, Y).
X = homer, Y = bart ;
X = abe, Y = homer .
?- grandfather(X, Y).
X = abe, Y = bart .
\end{lstlisting}

Die Antworten sind alle möglichen Kombinationen aus den Variablen, die den Fakten und Relationen entsprechen.

Prolog ist hierbei anders als \enquote{andere} Programmiersprachen, da es sich um eine deklarative Programmiersprache handelt. Die Relationen basieren auf zuvor definierten Fakten.

VIPER, die VIPER Interactive Prolog Education Runtime, ist ein Programm zur Bearbeitung und dem Testen von einfachen Prolog-Programmen. Über die visuelle Schnittstelle ist es dem Nutzer möglich, Prolog zu schreiben, Abfragen zu stellen und diese visualisieren zu lassen.

Dank des automatisch generierten Graphen ist es dem Nutzer hierbei möglich, die Interpretation des Programmes schrittweise anzuzeigen und nachzuvollziehen.

Damit soll dem Nutzer die Funktionsweise von Prolog-Programmen durch die graphische Visualisierung näher gebracht und zum verbesserten Verständnis von Prolog beigetragen werden.

\pagebreak
\section{Kriterien}
% Diese Section sollte kurz und knapp "für Manager" sein
% und auf eine Seite passen.

\subsection{Muss}

\criterium{Öffnen}{crt:open}

Das Programm soll bereits vorhandene Prolog-Programme öffnen können, damit auf diesen Abfragen durchgeführt und diese visualisiert werden können.

\criterium{Speichern}{crt:save}

Das Programm soll Änderungen am momentan geöffnetem Prolog-Programm speichern können. Wurde die Datei seit dem Öffnen anderweitig verändert, so wird sie überschrieben.

\criterium{Interpretation eines Prolog-Programms mit begrenztem Umfang}{crt:interpretation}

% Verweis auf Glossareintrag
Das Programm kann eine Teilmenge der Sprache Prolog interpretieren:

Es gibt IDs, Variablen und Zahlen die wie folgt notiert werden:

\begin{lstlisting}
id := [a-z][a-zA-Z0-9]*
var := [A-Z][a-zA-Z0-9]*
num := [0-9]*
\end{lstlisting}

Es gibt Terme welche sich aus obigem zusammensetzen:

\begin{lstlisting}
Term := Funktor | var | num
Funktor := id | id( Term{, Term}* )
\end{lstlisting}

Und zusätzlich gibt es Regeln und Ziele welche sich wie folgt zusammensetzen:

\begin{lstlisting}
Regel := Funktor . | Funktor :- Ziel {, Ziel}* .
Ziel := Funktor | Term = Term
\end{lstlisting}

Eine Regel die nur aus einem Funktor ohne Ziel besteht wird Fakt genannt.

Das Programm unterstützt die Darstellung von Listen. Die leere Liste wird durch \enquote{\texttt{[]}} dargestellt, eine Liste mit Inhalt wird durch \enquote{\texttt{[1,2,3]}} dargestellt und intern als Listenkopf und \enquote{Restliste} behandelt, das heißt:\newline
Liste: \texttt{[1,2,3]}\newline
In Prolog: \texttt{[1|teilliste1]}, \texttt{teilliste1=[2|teilliste2]}, \texttt{teilliste2=[3]}.

\criterium{Einzelschritt-Interpreter}{crt:interpreter}

% Verweis auf GUI und mögliche Anpassung des Schaltflächennamen
Das Programm bearbeitet Anfragen schrittweise. Nach jedem durchgeführten Teilschritt einer Abfrage wartet das Programm auf Interaktion vom Nutzer (drücken der Verarbeiten-Schaltfläche), bis es den nächsten Teilschritt bearbeitet.

\criterium{Visualisierung}{crt:visualization}

% Verweise auf GUI
Das Programm kann Abfragen zu einem Prolog-Programm mit Hilfe eines Graphen visualisieren. Dieser hat eine Baumstruktur und beinhaltet für jeden Abarbeitungsschritt einen eigenen Knoten.

\subsection{Kann}

\criteriumOptional{Zurückschreiten}{crt:stepback}

% Verweis auf GUI
Das Programm soll es dem Nutzer ermöglichen, beliebig viele Schritte schrittweise zurückzugehen.

\criteriumOptional{Ausführung bis zur nächsten Ausgabe}{crt:continueto}

% Verweis auf GUI
Die Interpretation soll durch eine zusätzliche Schaltfläche bis zur nächsten Ausgabe ausgeführt werden können.

\criteriumOptional{Abbrechen}{crt:cancel}

% Verweis auf GUI
Das automatische Abarbeiten mehrerer Schritte soll durch das Betätigen einer Schaltfläche abgebrochen werden können.

\criteriumOptional{Cut}{crt:cut}

Das Programm soll die \enquote{Cut}-Funktionalität unterstützen. Mit dieser kann der Nutzer dem Interpreter durch das hinzufügen eines \enquote{\texttt{!}} als Teilziel verbieten zu einer bestimmten Stelle zurück zu springen.

\criteriumOptional{Arithmetik}{crt:maths}

Das Programm soll grundlegende Arithmetik unterstützen. Da Terme in Prolog nur für sich selber stehen, können Abfragen wie \enquote{$4 = 1 + 3$} nicht bearbeitet werden. Daher wird der Interpreter um ein Rechenoperator \enquote{\texttt{is}} erweitert, welcher solche arithmetischen Abfragen ermöglicht.

\criteriumOptional{Standardbibliothek}{crt:standardlib}

Das Programm soll eine Standardbibliothek in Form eines Prolog-Programms mit nützlichen, vordefinierten Regeln unterstützen, die standardmäßig beim Starten des Programms mit eingebunden wird.

\criteriumOptional{Standardbibliothek deaktivieren}{crt:disablelib}

Das Programm soll es dem Nutzer ermöglichen, die eingebundene Standardbibliothek deaktivieren zu können.

\criteriumOptional{Export von Visualisierungsbäumen als LaTeX-Code}{crt:latex}

Das Programm kann einen Visualisierungsbaum als LaTeX-Code exportieren, damit dieser vereinfacht in Dokumente eingebunden werden kann.

\criteriumOptional{Export von Visualisierungsbäumen als Bilddatei}{crt:export}

Das Programm kann einen Visualisierungsbaum als Bilddatei im SVG- oder PNG-Format exportieren.

\criteriumOptional{Syntaxhighlighting}{crt:syntaxhighlighting}

Das Programm soll das farbliche Hervorheben bestimmter Regeln und ihres/ihrer korrespondieren Knoten in der Visualisierung unterstützen. Der Code wird dabei farblich passend hervorgehoben. Identifier und Variablen werden unterschiedlich zu Zahlen eingefärbt. Ebenfalls unterscheiden sich die Farben von umschließenden Klammern. Die Operatoren \texttt{=}, \texttt{:-}, \texttt{is} und \texttt{!} sind farblich von allem anderen unterscheidbar.

\criteriumOptional{\enquote{Pretty-Printing} von Listen}{crt:prettyprinting}

Das Programm soll Listen bei der Ausgabe einheitlich auf \enquote{\texttt{[x,y,z]}} formatieren.

\subsection{Abgrenzung}

\criteriumNot{Voller Sprachsupport}{crt:fullsupport}

Das Programm hat kein Verständnis für Prolog-Sprachfeatures außerhalb der vorgestellten Prolog-Teilmenge.

\criteriumNot{Andere Programmiersprachen}{crt:otherlanguages}

Das Programm beschränkt sich auf die Prolog-Sprache und bietet keine offizielle Unterstützung für Prolog-Dialekte oder andere Programmiersprachen jeglicher Art.

\criteriumNot{Nutzung in einer Kommandozeile}{crt:cli}

Das Programm beschränkt sich auf eine graphische Darstellung über GUI-Elemente. Eine Interaktion über die Konsole wird nicht unterstützt.

\criteriumNot{Professionelle Anwendung}{crt:professionaluse}

Das Programm ist nicht für professionelle Anwendungszwecke ausgelegt.

\pagebreak
%%%%%%%%%%%%%%
\section{Produkteinsatz}

Das Programm soll als graphisches Prolog-Lerntool betrieben werden.

Die Zielgruppe des Lerntools sind Lehrende, Studierende und Enthusiasten.

Das Programm soll sich auf eine Teilmenge der Prolog-Sprache beschränken, diese jedoch voll unterstützen.

Das Programm soll für die Teilmenge der Sprache eine Lernhilfe sein und das Verständnis für die Funktionsweise von Prolog, mit Hilfe von schrittweiser Visualisierung, stärken.

Das Programm ermöglicht es mit Hilfe eines eingebauten Editors Prolog-Programme zu bearbeiten und zu erweitern.

\section{Produktumgebung}

Das Programm soll als graphische Applikation auf einem Desktop-System betrieben werden.

Es stehen mindestens 2 AMD64/x86 Kerne mit insgesamt 2GB shared RAM zur Verfügung.

Unterstützte Betriebssysteme sind Windows ab Version 7 und aufwärts, macOS 10.9 aufwärts sowie Ubuntu Linux 16.04.

Eine Maus sowie eine Tastatur sind als Eingabegeräte angeschlossen und funktionsfähig.

Eine Installation des Java Runtime Environments Version 8 aufwärts ist auf dem System vorhanden.

\newpage

%%%%%%%%%%%
\section{Produktdaten}

\textbf{Zuletzt geöffnete Dateien} \\
Die Pfade der fünf zuletzt geöffneten Dateien werden für einen Eintrag in der Menüleiste gespeichert.

Außer den oben genannten werden keinerlei Daten gespeichert.
%%%%%%%%%%%
\section{Funktionale Anforderungen}

\functionality{Erstellen eines neuen Prolog-Programms}{fnc:new}
\fulfills{crt:new}

Das Programm stellt einen Editor bereit, in dem ein leeres Prolog-Programm angelegt werden kann. Sollte der Editor zuvor bereits ungesicherten Inhalt besitzen, so wird der Nutzer aufgefordert, diesen zu speichern. Der alte Inhalt wird daraufhin verworfen und ein neues Prolog-Programm angelegt.

\functionality{Öffnen eines Prolog-Programms}{fnc:open}
\fulfills{crt:open}

Das Programm ist in der Lage, Prolog-Programmdateien zu öffnen. Der Datei-Inhalt wird dabei in den Editor geladen und angezeigt. Analog wird zur Erstellung eines neuen Prolog-Programms, falls nötig, zur Speicherung ungesicherter Inhalte aufgefordert und das alte Prolog-Programm daraufhin verworfen.

\functionality{Öffnen eines zuletzt verwendeten Prolog-Programms}{fnc:recentfiles}
\fulfills{crt:recentfiles}

Das Programm bietet einen Schnellzugriff auf bis zu fünf der zuletzt verwendeten Dateien an. Diese können analog zu F2 geöffnet werden.

\functionality{Bearbeiten eines Prolog-Programms}{fnc:editor}
\fulfills{crt:save}

Das Prolog-Programm kann im Editor bearbeitet werden. Die Änderungen werden erst beim Speichern zurückgeschrieben.

\functionality{Speichern des Editor-Inhalts}{fnc:save}
\fulfills{crt:save}

Das Programm kann den Inhalt des Editors auf die Festplatte schreiben. Wurde das Prolog-Programm bisher noch nicht gespeichert, so kann über einen Auswahldialog eine neue Datei angelegt werden. Der Inhalt der Datei wird ohne weitere Überprüfung überschrieben.

\functionality{Parsen eines Prolog-Programms}{fnc:parser}
\fulfills{crt:parser}

Das geöffnete Prolog-Programm kann durch einen Parser verarbeitet werden. Wird der Parser gestartet, werden die Fenster der Konsole und der Visualisierung geleert.

\functionality{Fehlerausgabe beim Parsen eines inkorrekten Prolog-Programms}{fnc:errorcheck}
\fulfills{crt:errorcheck}

Der Parser erkennt Fehler innerhalb des geöffneten Prolog-Programms bei der Verarbeitung. Fehlermeldungen werden über das verfügbare Konsolen-Fenster ausgegeben.

\functionality{Eingabe von Prolog-Abfragen in die Konsole}{fnc:shell}
\fulfills{crt:shell}

Bei erfolgreicher Verarbeitung einer fehlerfreien Datei durch den Parser erlaubt die angezeigte Konsole die Eingabe von Abfragen. Sollten erneut Änderungen an dem geöffneten Prolog-Programm stattfinden, so wird die Eingabe in die Konsole sowie jegliche Interaktion mit der Visualisierung gesperrt bis der veränderte Quelltext erneut vom Parser verarbeitet wurde.

\functionality{Interpretation von Prolog-Abfragen in der Konsole}{fnc:interpreter}
\fulfills{crt:interpreter}

Abfragen, welche in der Konsole eingegeben wurden, werden nach einer Bestätigung mit der Eingabe-Taste schrittweise interpretiert. Ausgaben des Interpreters werden in der Konsole angezeigt. Nach dem Betätigen der Schaltfläche wird ausschließlich der erste Interpretationsschritt durchgeführt. Der Nutzer hat die Möglichkeit, diese Interpretation über eine Schritt-Schaltfläche schrittweise fortzuführen. Fehler bei der Interpretation einer Abfrage werden über das Konsolen-Fenster ausgegeben und die weitere Verarbeitung wird abgebrochen. Syntaktische Fehler bei Abfragen werden über das Konsolenfenster ausgegeben und die weitere Verarbeitung wird unterbrochen.

\functionality{Visualisierung des aktuellen Interpretationsschrittes mittels eines Graphen}{fnc:graph}
\fulfills{crt:graph}

Bei aktiver Interpretation einer Abfrage wird eine Visualisierung für den aktuellen Interpretationsschritt generiert und im Visualisierungs-Fenster angezeigt. Sollte zuvor eine Visualisierung in diesem Fenster angezeigt worden sein, wird diese aus dem Fenster gelöscht.

\functionality{Vergrößern und Verkleinern der Visualisierung durch Schaltflächen oder das Mausrad}{fnc:zoom}
\fulfills{crt:zoom}

Über die Verwendung des Mausrads oder der Plus- und Minus-Schaltflächen lässt sich der angezeigte Ausschnitt des Visualisierungs-Graphen vergrößern oder verkleinern.

\functionality{Navigation des Visualisierung durch Bewegungen mit der Maus}{fnc:move}
\fulfills{crt:zoom}

Durch Drücken und Halten der linken Maustaste lässt sich der angezeigte Ausschnitt des Graphen bewegen, wodurch in diesem navigiert werden kann.

\functionality{Zurückschreiten während der Interpretation}{fnc:stepback}
\fulfills{crt:stepback}

Eine Rückschritt-Schaltfläche erlaubt bei Betätigung den jeweils vorhergehenden Schritt rückgängig zu machen. Im Falle des ersten Schrittes hat das Betätigen dieser Schaltfläche keinen Effekt.

\functionality{Ausführung der Interpretation bis zur nächsten Ausgabe}{fnc:continue}
\fulfills{crt:continue}

Eine Fortsetzen-Schaltfläche erlaubt bei Betätigung die Ausführung bis zur nächsten Ausgabe fortzuführen.

\functionality{Abbrechen einer Interpretation}{fnc:cancel}
\fulfills{crt:cancel}

Im Falle einer Interpretation die mehrere Schritte hintereinander ausführt (Fortsetzen bis zur nächsten Ausgabe), kann die laufende Interpretation über eine Abbrechen-Schaltfläche frühzeitig beendet werden.

\functionality{Exportieren der angezeigten Visualisierung in einem beliebigen Schritt als LaTeX-Dokument}{fnc:latexexport}
\fulfills{crt:latexexport}

Die aktuell angezeigte Visualisierung lässt sich als LaTeX-Dokument exportieren.

\functionality{Exportieren der angezeigten Visualisierung in einem beliebigen Schritt als Grafik}{fnc:imageexport}
\fulfills{crt:imageexport}

Die aktuell angezeigte Visualisierung lässt sich als Bild im PNG- oder SVG-Format exportieren.

\functionality{Deaktivierung der Standardbibliothek}{fnc:disablelib}
\fulfills{crt:disablelib}

Die automatisch eingebundene Standardbibliothek kann über eine Schaltfläche deaktiviert werden. Von der Standardbibliothek zur Verfügung gestellte Prädikate werden nun nicht mehr berücksichtigt.

%TODO: Richtlinien als Liste?
\functionality{Formatierung des Quellcodes}{fnc:formatter}
\fulfills{crt:formatter}

Eine automatische Formatierung von Prolog-Quellcode ist über eine Schaltfläche möglich. Die Formatierung ist hierbei vorgegeben und kann nicht verändert werden. Die Formatierung sieht folgendes vor: Jede Regel wird in ihre eigene Zeile gelegt. Hat eine Regel mehrere Teilziele, so wird die Regelzeile nach dem \enquote{\texttt{:-}}-Operator umgebrochen und alle Teilziele werden in eigene Zeilen gelegt, welche mit zwei Leerzeichen eingerückt sind. Bereits gesetzte Leerzeilen werden beibehalten. Fehlende Leerzeichen vor und hinter dem \enquote{\texttt{:-}}-Operator sowie nach Kommata in Parameterlisten werden eingefügt.

\functionality{Wechsel der verwendeten Sprache}{fnc:translation}
\fulfills{crt:translation}

Über die Menüleiste kann die Sprache der GUI-Elemente zwischen Englisch und Deutsch gewechselt werden.

\functionality{Dynamisches Skalieren des Hauptfensters mit der Maus}{fnc:resizeable}
\fulfills{crt:resizeable}

Das Hauptfenster des Programms kann mit der Maus in der Größe verändert werden.

%%%%%%%%%%%
\section{Nicht-Funktionale Anforderungen}

\nonFunctionality{Das Programm startet auf einem modernen System innerhalb von 30 Sekunden und ist voll einsatzbereit.}{nfc:startup}

\nonFunctionality{Ein importiertes oder geschriebenes Prolog Programm ohne Verwendung von Rekursion und im Umfang von maximal 100 Zeilen Code ist innerhalb von maximal 3 Sekunden interpretiert und innerhalb von weiteren 5 Sekunden visualisiert.}{nfc:timelimit}

\nonFunctionality{Das Design wirkt modern und ansprechend.}{nfc:design}

\nonFunctionality{Das Programm lässt sich ohne die manuelle Installation weiterer Programme durch das Ausführen einer .jar Datei starten.}{nfc:installation}

\nonFunctionality{Das Programm ist ohne Abhängigkeiten kleiner als 50 MiB, mit Abhängigkeiten kleiner als 200 MiB.}{nfc:filesize}

\nonFunctionality{Das Öffnen einer Prolog-Programmdatei mit einer Größe von unter 1 MiB geschieht in unter 5 Sekunden.}{nfc:loadfile}

\nonFunctionality{Fehlerhafte Prolog-Programme sollen nie zu einem Absturz des Programms führen.}{nfc:crashresistance}

\nonFunctionality{Der Prolog Interpreter lässt sich in seiner Funktionalität einfach erweitern, um weitere Sprachfeatures zu unterstützen.}{nfc:extendable}

\pagebreak
\section{Tests}

\test{Öffnen einer Prolog-Programmdatei}{tst:open}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Es ist kein Prolog-Programm im Editor geöffnet.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Datei-Auswahldialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über das Auswahlfenster ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche.}
{Die Datei wird im Editor-Fenster geöffnet.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Öffnen einer Prolog-Programmdatei während im Editor bereits ein Programm eingegeben wurde mit Speichern des geschriebenen Programmes}{tst:openanother}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Im Editor wurde ein Prolog-Programm händisch eingegeben.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Datei-Auswahldialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über das Auswahlfenster ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche.}
{Ein Dialogfenster fragt den Nutzer, ob das im Editor eingegebene Prolog-Programm gespeichert oder verworfen werden soll.}

\teststep{Der Nutzer hat die Wahl das im Editor geschriebene Prolog-Programm zu speichern oder zu verwerfen.}
{Der Nutzer betätigt die Speichern-Schaltfläche.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Speicherort und wählt einen Dateinamen. Anschließend betätigt er die Speichern-Schaltfläche.}
{Das im Editor geöffnete Prolog-Programm wird in die gewählte Datei gespeichert. Die zu öffnende Datei wird in den Editor geladen und überschreibt den bisherigen Inhalt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Öffnen einer Prolog-Programmdatei während im Editor bereits ein Prolog-Programm eingegeben wurde mit Verwerfen des geschriebenen Prolog-Programmes}{tst:openanother2}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Im Editor wurde ein Prolog-Programm händisch eingegeben.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Datei-Auswahldialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über das Auswahlfenster ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche.}
{Ein Dialogfenster fragt den Nutzer, ob das im Editor eingegebene Prolog-Programm gespeichert oder verworfen werden soll.}

\teststep{Der Nutzer hat die Wahl, das im Editor geschriebene Prolog-Programm zu speichern oder zu verwerfen.}
{Der Nutzer betätigt die Verwerfen-Schaltfläche.}
{Das im Editor geöffnete Prolog-Programm wird verworfen. Die zu öffnende Datei wird in dem Editor geöffnet und überschreibt den bisherigen Inhalt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Syntaktische Hervorhebung von Prolog-Stichworten}{tst:syntaxhighlighting}
\tests{fnc:syntaxhighlighting}

\teststep{Der Nutzer hat ein leeres Editor-Fenster vor sich.}
{Der Nutzer gibt ein gültiges Prolog-Programm im Editor ein.}
{Der Code wird farblich passend hervorgehoben. Identifier, Variablen und Zahlen werden dabei unterschiedlich eingefärbt. Ebenfalls unterscheiden sich die Farben von umschließenden Klammern. Die Operatoren \texttt{=}, \texttt{:-}, \texttt{is} und \texttt{!} sind farblich von allem anderen unterscheidbar.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Speichern eines im Editor geschrieben Prolog-Programmes}{tst:save}
\tests{fnc:save}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Ein Prolog-Programm ist im Editor geöffnet.}
{Der Nutzer wählt über die Menüleiste die Speichern-Funktion aus.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Speicherort und Dateinamen aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Der Inhalt des Editors wird an den gewählten Ort geschrieben.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Inkorrektes Prolog-Programm}{tst:syntaxcheck}
\tests{fnc:syntaxcheck}

\teststep{Der Nutzer hat ein inkorrektes Prolog-Programm in den Editor eingetragen.}
{Der Nutzer betätigt die Parsen-Schaltfläche, um das Prolog-Programm zu parsen.}
{Die Ausführung wird abgebrochen und eine verständliche Fehlermeldung wird in der Konsole angezeigt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Interpretierung vom Beispielprogramm}{tst:simpsons}
\tests{fnc:interpreter}

\teststep{Das Beispielprogramm ist im Editorfenster eingegeben oder aus einer Datei geöffnet worden.}
{Der Nutzer klickt auf die Parsen-Schaltfläche des Hauptfensters.}
{Das Prolog-Programm wird erfolgreich geparst, es kommt zu keinen Fehlern. Die Konsole erwartet eine Eingabe.}

\teststep{Das Prolog-Programm wurde geparst und die Konsole erwartet eine Eingabe.}
{Der Nutzer gibt die Abfrage \texttt{father(X, bart).} in der Konsole ein.}
{Das Prolog-Programm wird interpretiert und die Wurzel des Visualisierungsbaums wird angezeigt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Interaktive Nutzung des Interpreters}{tst:ask}
\tests{fnc:ask}

\teststep{Der Nutzer hat ein fehlerloses Prolog-Programm im Editor eingegeben.}
{Der Nutzer betätigt die Parsen-Schaltfläche im Hauptfenster.}
{In der Konsole wird eine Erfolgsnachricht ausgegeben.}

\teststep{Die Konsole erwartet eine Eingabe.}
{Der Nutzer gibt eine Anfrage mit mehreren Antworten ein und bestätigt die Eingabe.}
{Die Abfrage wird mittels eines Graphen visualisiert.}

\teststep{Die Wurzel des Graphen wird angezeigt.}
{Der Nutzer betätigt die Schritt-Schaltfläche bis eine Antwort gefunden wurde.}
{Zwischenschritte werden visualisiert. In der Konsole erscheint die Antwort.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Zoomen innerhalb eines Visualisierungsbaumes}{tst:zoom}
\tests{fnc:zoom}

\teststep{Eine Abfrage ist mittels eines Graphen visualisiert.}
{Der Nutzer bewegt das Mausrad über dem Graphen zu sich bzw. nach hinten.}
{Aus dem Graphen wird heraus gezoomt, der Graph wird kleiner.}

\teststep{Eine Abfrage ist mittels eines Graphen visualisiert.}
{Der Nutzer bewegt das Mausrad über dem Graphen von sich weg bzw. nach vorne.}
{Es wird in den Graphen herein gezoomt, der Graph wird größer.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Bewegung innerhalb eines Visualisierungsbaumes}{tst:move}
\tests{fnc:move}

\teststep{Eine Abfrage ist mittels eines Graphen visualisiert.}
{Der Nutzer hält die linke Maustaste gedrückt und bewegt die Maus.}
{Der Graph bewegt sich passend zu der Mausbewegung.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Formatierung von Quellcode}{tst:formatter}
\tests{fnc:formatter}

\teststep{Der Nutzer hat das Beispielprogramm ohne Leerzeichen und Einrückungen im Editor eingegeben oder aus einer Datei geöffnet.}
{Der Nutzer betätigt die Formatieren-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird automatisch wie im Anhang formatiert.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Export als Bilddatei für Foliensätze}{tst:latexexport}
\tests{fnc:latexexport}

\teststep{Ein Prolog-Programm ist im Editor geöffnet und ein beliebiger Schritt einer Anfrage als Graph visualisiert.}
{Der Nutzer wählt über die Menüleiste die Exportieren-Funktion aus.}
{Ein Auswahl-Dialog öffnet sich.}

\teststep{Ein Dialog mit den Auswahlmöglichkeiten \enquote{SVG} und \enquote{PNG} ist geöffnet}
{Der Nutzer wählt eine der beiden Optionen aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Dateipfad aus und gibt einen Dateinamen ein. Anschließend betätigt er die Speichern-Schaltfläche.}
{Die Visualisierung wird im ausgewählten Format an dem gewählten Ort gespeichert. Die passende \texttt{.svg} bzw. \texttt{.png} Dateieendung wird wenn nötig ergänzt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\test{Export als LaTeX für Foliensätze}{tst:latexexporttikz}
\tests{fnc:latexexport}

\teststep{Ein Prolog-Programm ist im Editor geöffnet und ein beliebiger Schritt einer Anfrage als Graph visualisiert.}
{Der Nutzer wählt über die Menüleiste die Exportieren-Funktion aus.}
{Ein Auswahl-Dialog öffnet sich.}

\teststep{Ein Dialog mit den Auswahlmöglichkeiten Grafik (\enquote{SVG}, \enquote{PNG}) und LaTeX ist geöffnet.}
{Der Nutzer wählt die LaTeX Option aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Dateipfad aus und gibt einen Dateinamen ein. Anschließend betätigt er die Speichern-Schaltfläche.}
{Die Visualisierung wird als TeX-Datei an dem gewählten Ort gespeichert. Die passende \texttt{.tex} Dateiendung wird wenn nötig ergänzt.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: Systemtests (komplette Abläufe)

%%%%%%%%%%%%%
\pagebreak
\appendix

\section{Seitenentwürfe}

\begin{figure}[hb]
\fbox{\includegraphics[width=\textwidth]{image/main_view.png}}
\caption{\label{fig:editor}
Hauptfenster
}
\end{figure}

\section{Glossar}

\textbf{Nutzer}:
Eine Person, welche den Dienst nutzt.

\end{document}
