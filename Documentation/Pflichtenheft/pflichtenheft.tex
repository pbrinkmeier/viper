\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\title{VIPER Interactive Prolog Education Runtime}
\subtitle{Pflichtenheft}
\author{Paul Brinkmeier, Lukas Brocke, Jannik Koch, Aaron Maier, Christian Oder}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage{amsmath} % for $\text{}$

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{courier}
\hypersetup{
	pdftitle={Pflichtenheft},
}

\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\usepackage{pflichtenheft}

\lstset{basicstyle=\ttfamily,breaklines=true}

% Don't strech across whole page
\raggedbottom

% Start new page with each section
\usepackage{sectsty}
\sectionfont{\clearpage}

\begin{document}
\maketitle

\section{Einleitung}

Prolog ist eine logische Programmiersprache die ein deklaratives Programmieren ermöglicht.

Prolog operiert auf einer Wissensdatenbank, deren Einträge sich Fakten und Regeln nennen. Ein Beispiel:

\begin{lstlisting}
father(abe, homer).
father(homer, bart).
\end{lstlisting}

So gilt, dass Abe der Vater von Homer und Homer der Vater von Bart ist.

Für eine Abfrage erhalten wir folgende Lösungen:

\begin{lstlisting}
?- father(homer, bart).
yes
?- father(bart, abe).
no .
\end{lstlisting}

Nun ist es möglich, auf Fakten oder anderen Regeln basierende Regeln einzuführen. Definieren wir also Großväter väterlicherseits als alle Väter von Vätern, indem wir Variablen als Platzhalter verwenden. Diese beginnen mit Großbuchstaben, Funktoren und Atome mit Kleinbuchstaben.

\begin{lstlisting}
paternalGrandfather(X, Y) :- father(X, Z), father(Z, Y).
\end{lstlisting}

Selbiges ist möglich für Abfragen.

\begin{lstlisting}
?- father(X, bart).
X = homer
?- paternalGrandfather(X, Y).
X = abe, Y = bart
\end{lstlisting}

Die Antworten sind alle möglichen Kombinationen aus den Variablen, die den Fakten und Regeln entsprechen.

Prolog ist hierbei anders als \enquote{andere} Programmiersprachen, da es sich um eine deklarative Programmiersprache handelt. Bei der Programmierung in Prolog steht die Beschreibung eines Problems im Vordergrund. Der Prolog-Interpreter wendet einen festen Algorithmus an, um durch Unifikation Lösungen zu finden.

VIPER, die VIPER Interactive Prolog Education Runtime, ist ein Programm zur Bearbeitung und dem Testen von einfachen Prolog-Programmen. Über die visuelle Schnittstelle ist es dem Nutzer möglich, Prolog zu schreiben, Abfragen zu stellen und die Abarbeitung dieser visualisieren zu lassen.

Die Visualisierung für einzelne Schritte der Interpretation ist hierbei als gerichteter Graph realisiert. Der genannte Graph entspricht einem Baum mit \enquote{Rückwärts-Kanten} (da einzelne Schritte visualisiert werden, gibt es jeweils höchstens eine Rückwärts-Kante pro Visualisierung-Schritt), die das Backtracking veranschaulichen.

Unter Zuhilfenahme der Visualisierung soll der Nutzer die Interpretation eines Prolog-Programms schrittweise nachvollziehen können. Dies soll dem Nutzer die Funktionsweise von Prolog-Programmen näher bringen und das Verständnis für die Eigenschaften der Sprache stärken.

\section{Kriterien}

\subsection{Muss}

\criterium{Erstellen eines neuen Prolog-Programms}{crt:create}

Der Inhalt des Editor kann gelöscht werden um ein neues Prolog-Programm anzulegen.

\criterium{Öffnen eines Prolog-Programms}{crt:open}

Das Programm kann bereits vorhandene Prolog-Programme öffnen.

\criterium{Bearbeiten eines Prolog-Programms}{crt:edit}

Das Programm erlaubt es dem Nutzer, Änderungen an einem geöffneten Prolog-Programm durchzuführen. Dabei wird die aktuelle Interpretation gestoppt und die Visualisierung gelöscht.

\criterium{Speichern eines Prolog-Programms}{crt:save}

Das Programm kann Änderungen am momentan geladenen Prolog-Programm speichern. Der Inhalt der Datei wird dabei überschrieben.

\criterium{Parsen eines Prolog-Programms mit begrenztem Sprachumfang}{crt:parser}

Das Programm kann eine Teilmenge der Sprache Prolog durch einen Parser verarbeiten. Diese unterstützt als Terme Funktoren, Variablen und Zahlen. Regeln werden mit beliebig vielen Teilzielen unterstützt und als Ziele ausschließlich Funktoren.

\criterium{Eingabe von Abfragen}{crt:request}

Das Programm erlaubt es dem Nutzer Abfragen in das Eingabefeld einzugeben. Dabei wird die aktuelle Interpretation abgebrochen und die Visualisierung gelöscht.

\criterium{Einzelschritt-Interpretation von Abfragen}{crt:interpreter}

Das Programm bearbeitet Abfragen schrittweise. Nach jedem durchgeführten Teilschritt einer Abfrage wartet das Programm auf eine Interaktion vom Nutzer (Klicken der \enquote{Nächster Schritt}-Schaltfläche), bis es den nächsten Teilschritt bearbeitet.

\criterium{Visualisierung als Graph}{crt:visualization}

Das Programm kann den aktuellen Zustand der Abarbeitung einer Abfrage zu einem Prolog-Programm durch einen Graphen visualisieren.

\criterium{Ausgabe von Lösungen zu einer Abfrage}{crt:answer}

Das Programm kann Lösungen zu einer Abfrage in der Konsole ausgeben. Dabei wird bei einer Abfrage ohne Variablen \enquote{\texttt{ja}} oder \enquote{\texttt{nein .}} ausgegeben. Beinhaltet die Abfrage Variablen, so werden mögliche Variablenbelegungen ausgegeben. Bei frei belegbaren Variablen wird \enquote{\texttt{<beliebig>}} ausgegeben. Gibt es keine (weitere) Lösung, so wird \enquote{\texttt{nein .}} ausgegeben.

\criterium{Navigation in der Visualisierung}{crt:navigation}

Das Programm ermöglicht es dem Nutzer das Bewegen des angezeigten Ausschnitts der Visualisierung und das Zoomen.

\subsection{Kann}

\criteriumOptional{Zurückschreiten}{crt:stepback}

Das Programm soll es dem Nutzer ermöglichen, beliebig viele Schritte schrittweise zurückzugehen.

\criteriumOptional{Ausführung bis zur nächsten Lösung}{crt:continue}

Die Interpretation soll durch eine zusätzliche Schaltfläche bis zur nächsten Lösung ausgeführt werden können. Diese Aktion kann durch das Betätigen der \enquote{Abbrechen}-Schaltfläche abgebrochen werden. Dabei wird der aktuelle Interpretationsschritt fertig berechnet und anschließend wird die Interpretation abgebrochen.

\criteriumOptional{Cut}{crt:cut}

Das Programm soll die \enquote{Cut}-Funktionalität unterstützen.

\criteriumOptional{Arithmetik}{crt:maths}

% TODO Aus dem glosar definitionend hochziehen
Das Programm soll grundlegende Arithmetik unterstützen.

\criteriumOptional{Standardbibliothek}{crt:standardlib}

Das Programm soll eine Standardbibliothek mit nützlichen, vordefinierten Regeln unterstützen, die standardmäßig beim Starten des Programms mit eingebunden wird. Bereits implementierte Regeln, die vom Nutzer nochmals implementiert werden, werden als zusätzliche Regeln zu den bereits vorhandenen hinzugefügt, nachdem eine Warnung ausgegeben wurde.

\criteriumOptional{Standardbibliothek deaktivieren und aktivieren}{crt:disablelib}

Das Programm soll es dem Nutzer ermöglichen, die eingebundene Standardbibliothek deaktivieren und wieder aktivieren zu können.

\criteriumOptional{Export der Visualisierung als LaTeX-Code}{crt:latexexport}

Das Programm kann die Visualisierung als LaTeX-Code exportieren, damit dieser vereinfacht in Dokumente eingebunden werden kann.

\criteriumOptional{Export der Visualisierung als Bilddatei}{crt:imageexport}

Das Programm kann die Visualisierung als Bilddatei im SVG- oder PNG-Format exportieren.

\criteriumOptional{\enquote{Pretty-Printing} von Listen}{crt:prettyprinting}

Das Programm soll Listen bei der Ausgabe einheitlich auf \enquote{\texttt{[x, y, z]}} formatieren.

\criteriumOptional{Formatierung von Quelltext}{crt:formatting}

Das Programm soll Quelltext durch das Betätigen der \enquote{Formatieren}-Schaltfläche in ein vorgeschriebenes Format bringen können.

\criteriumOptional{Wechseln der Sprache zwischen Deutsch und Englisch}{crt:translation}

Die Programmoberfläche soll die Sprachen Deutsch und Englisch unterstützen. Durch eine Schaltfläche ist es möglich, zwischen diesen zu wechseln.

\criteriumOptional{Schnellzugriffsleiste}{crt:buttons}

%TODO siehe GUI
Das Programm soll, wie in den GUI Entwürfen eine Leiste mit Schaltflächen unter der Menüleiste besitzen.

\subsection{Abgrenzung}

\criteriumNot{Voller Sprachsupport}{crt:fullsupport}

%TODO Verweiß auf Krieterium
Das Programm unterstützt keine Prolog-Sprachfeatures außerhalb der vorgestellten Prolog-Teilmenge.

\criteriumNot{Andere Programmiersprachen}{crt:otherlanguages}

Das Programm beschränkt sich auf die Prolog-Sprache und bietet keine offizielle Unterstützung für Prolog-Dialekte oder andere Programmiersprachen jeglicher Art.

\criteriumNot{Nutzung in einer Kommandozeile}{crt:cli}

Das Programm beschränkt sich auf eine grafische Darstellung über GUI-Elemente. Eine Interaktion über die Kommandozeile wird nicht unterstützt.

\criteriumNot{Professionelle Anwendung}{crt:professionaluse}

Das Programm ist nicht für professionelle Anwendungszwecke ausgelegt.

\criteriumNot{Parser}{crt:parsernot}

Der Parser ist gegeben und wird nicht selbst implementiert.

\section{Produkteinsatz}

Das Programm soll als grafisches Prolog-Lerntool betrieben werden.

Die Zielgruppe des Lerntools sind Lehrende, Studierende und Enthusiasten.

Das Programm soll sich auf eine Teilmenge der Prolog-Sprache beschränken, diese jedoch voll unterstützen.

Das Programm soll für die Teilmenge der Sprache eine Lernhilfe sein und das Verständnis für die Funktionsweise von Prolog, mit Hilfe von schrittweiser Visualisierung, stärken.

Das Programm ermöglicht es mit Hilfe eines eingebauten Editors Prolog-Programme zu bearbeiten und zu erweitern.

\section{Produktumgebung}

Das Programm soll als grafische Applikation auf einem Desktop-System betrieben werden.

Es stehen mindestens 2 AMD64/x86 Kerne mit insgesamt 2GB shared RAM zur Verfügung.

Unterstützte Betriebssysteme sind Windows ab Version 7 und aufwärts, macOS 10.9 aufwärts sowie Ubuntu Linux 16.04.

Eine Maus sowie eine Tastatur sind als Eingabegeräte angeschlossen und funktionsfähig.

Eine Installation des Java Runtime Environments Version 8 aufwärts ist auf dem System vorhanden.

\section{Produktdaten}

\textbf{Zuletzt geöffnete Dateien} \\
Die Pfade der fünf zuletzt geöffneten Dateien werden für einen Eintrag in der Menüleiste gespeichert.

\textbf{Eingestelle Sprache} \\
Die letzte vom Nutzer ausgewählte GUI-Sprache wird gespeichert, damit diese nach einem Programm-Neustart nicht erneut eingestellt werden muss.

\textbf{Standardbibliothek} \\
Der Status der Standardbibliothek (\enquote{Aktiviert}/\enquote{Deaktiviert}) wird gespeichert, damit diese Einstellung nach einem Programm-Neustart erhalten bleibt.

\section{Funktionale Anforderungen}

\functionality{Erstellen eines neuen Prolog-Programms}{fnc:new}
\fulfills{crt:create}

Das Programm stellt eine Schaltfläche zum Leeren des Editors bereit. Sollte beim Betätigen dieser Schaltfäche der Inhalt des Editors ungesichert sein, so wird der Nutzer aufgefordert, diesen zu speichern. Hierbei kann entweder die alte Datei überschrieben oder eine neue Datei angelegt werden. Der alte Editor-Inhalt, der Konsolen-Inhalt und die Visualisierung werden daraufhin verworfen.

\functionality{Öffnen eines Prolog-Programms}{fnc:open}
\fulfills{crt:open}

Das Programm ist in der Lage, Prolog-Programmdateien zu öffnen. Der Datei-Inhalt wird dabei in den Editor geladen und angezeigt. Analog wird zur Erstellung eines neuen Prolog-Programms, falls nötig, zur Speicherung ungesicherter Inhalte aufgefordert und das alte Prolog-Programm daraufhin verworfen.

\functionality{Öffnen eines zuletzt verwendeten Prolog-Programms}{fnc:recentfiles}
\fulfills{crt:open}

Das Programm bietet einen Schnellzugriff auf bis zu fünf der zuletzt verwendeten Dateien an. Diese können analog zu F2 geöffnet werden.

\functionality{Bearbeiten eines Prolog-Programms}{fnc:editor}
\fulfills{crt:edit}

Das Prolog-Programm kann im Editor bearbeitet werden. Die Änderungen werden erst beim Speichern zurückgeschrieben. Sollten nach dem Parsen erneut Änderungen an dem geöffneten Prolog-Programm durchgeführt werden, so wird das Eingabefeld sowie jegliche Interaktion mit der Visualisierung gesperrt, bis der veränderte Quelltext erneut vom Parser verarbeitet wurde.

\functionality{Speichern als}{fnc:saveas}
\fulfills{crt:save}

Beim Betätigen der \enquote{Speichern als}-Schaltfläche in der Menüleiste kann über einen Auswahl-Dialog eine Datei ausgewählt oder eine neue Datei angelegt werden. Anschließend wird der Inhalt des Editors an den gewählten Ort gespeichert.

\functionality{Speichern des Editor-Inhalts}{fnc:save}
\fulfills{crt:save}

Das Programm kann den Inhalt des Editors speichern. Ist der Dateiname bekannt, wird der Inhalt der Datei überschrieben. Sollte dies nicht der Fall sein, wird die \enquote{Speichern als...} Funktion ausgeführt.

\functionality{Parsen eines Prolog-Programms}{fnc:parser}
\fulfills{crt:parser}
\fulfills{crt:standardlib}

Das geöffnete Prolog-Programm kann durch einen Parser verarbeitet werden. Wird der Parser gestartet, werden die Fenster der Konsole und der Visualisierung geleert.

\functionality{Fehlerausgabe beim Parsen eines inkorrekten Prolog-Programms}{fnc:errorcheck}
\fulfills{crt:parser}

Der Parser erkennt Fehler innerhalb des geöffneten Prolog-Programms bei der Verarbeitung. Fehlermeldungen werden über die Konsole ausgegeben.

\functionality{Eingabe von Prolog-Abfragen in das Eingabefeld}{fnc:shell}
\fulfills{crt:request}

Bei erfolgreicher Verarbeitung einer korrekten Datei durch den Parser erlaubt das Eingabefeld die Eingabe von Abfragen. Eine korrekte Abfrage entspricht einem einzelnen Ziel.

\functionality{Syntaktische Fehler in der Abfrage}{fnc:inputerror}
\fulfills{crt:request}

Syntaktische Fehler in der Abfrage werden in der Konsole ausgegeben.

\functionality{Interpretation von Prolog-Abfragen}{fnc:interpreter}
\fulfills{crt:interpreter}

Abfragen, welche im Eingabefeld eingegeben wurden, werden nach einer Bestätigung mit der Eingabe-Taste schrittweise interpretiert.

\functionality{Weiterschreiten in der Interpretation}{fnc:interpreterforward}
\fulfills{crt:interpreter}

Nachdem die Interpretation gestartet wurde, wird durch das Betätigen der \enquote{Nächster Schritt}-Schaltfläche der nächsten Interpretationsschritt durchgeführt.

\functionality{Ausgaben des Interpreters}{fnc:interpreteroutput}
\fulfills{crt:answer}
\fulfills{crt:prettyprinting}

Der Interpreter gibt Lösungen zu einer Abfrage in der Konsole aus. Gibt es keine weitere Lösung mehr, so wird eine entsprechende Meldung ausgegeben.

\functionality{Visualisierung des aktuellen Interpretationsschrittes}{fnc:visualization}
\fulfills{crt:visualization}

Bei aktiver Interpretation einer Abfrage wird ein Graph für den aktuellen Interpretationsschritt generiert und im Visualisierungs-Fenster angezeigt. Sollte bereits ein Graph angezeigt werden wird dieser verworfen und durch den neuen ersetzt.

\functionality{Visualisierung einer erfolgreichen Unifikation}{fnc:unificationsuccess}
\fulfills{crt:visualization}

Gab es eine erfolgreiche Unifikation, so wird diese mit den entsprechenden Substitutionen visualisiert.

\functionality{Visualisierung einer fehlgeschlagenen Unifikation}{fnc:unificationfail}
\fulfills{crt:visualization}

Fehlgeschlagene Unifikationen werden visualisiert, jedoch nur, wenn die Funktorköpfe identisch sind. Da die Unifikation bei unterschiedlichen Funktorköpfen automatisch fehlschlägt, werden diese übersprungen und nicht visualisiert.

\functionality{Visualisierung von Backtracking}{fnc:backtracking}
\fulfills{crt:visualization}

%TODO Verlinken
Ein Backtrackingschritt wird entsprechend visualisiert.

\functionality{Vergrößern und Verkleinern der Visualisierung durch Schaltflächen oder das Mausrad}{fnc:zoom}
\fulfills{crt:navigation}

Über die Verwendung des Mausrads oder der Plus- und Minus-Schaltflächen lässt sich die Visualisierung vergrößern oder verkleinern.

\functionality{Ändern des Ausschnitts der Visualisierung durch Bewegungen mit der Maus}{fnc:move}
\fulfills{crt:navigation}

Durch Drücken und Halten der linken Maustaste lässt sich der angezeigte Ausschnitt der Visualisierung bewegen.

\functionality{Zurückschreiten während der Interpretation}{fnc:stepback}
\fulfills{crt:stepback}

Die Schaltfläche \enquote{Vorheriger Schritt} macht bei Betätigung den aktuellen Schritt rückgängig. Im Falle des ersten Schrittes ist diese Schaltfläche gesperrt.

\functionality{Ausführung der Interpretation bis zur nächsten Lösung}{fnc:continue}
\fulfills{crt:continue}

Die \enquote{Nächste Lösung}-Schaltfläche erlaubt bei Betätigung die Ausführung bis zur nächsten Lösung fortzuführen.

\functionality{Abbrechen einer Interpretation}{fnc:cancel}
\fulfills{crt:continue}

Im Falle einer Interpretation, die mehrere Schritte hintereinander ausführt (Fortsetzen bis zur nächsten Lösung), kann die laufende Interpretation über eine Abbrechen-Schaltfläche frühzeitig beendet werden. Hierbei wird der aktuelle Interpretationsschritt noch durchgeführt und anschließend wird die Interpretation beendet.

\functionality{Cut}{fnc:cut}
\fulfills{crt:cut}

Die Cut-Funktionalität soll unterstützt werden.

\functionality{Arithmetik}{fnc:maths}
\fulfills{crt:maths}

%TODO Link K4
Das Programm soll die in K4 beschriebene, grundlegende, Arithmetik unterstützen.

\functionality{Exportieren der angezeigten Visualisierung in einem beliebigen Schritt als LaTeX-Dokument}{fnc:latexexport}
\fulfills{crt:latexexport}

Die aktuell angezeigte Visualisierung lässt sich als LaTeX-Dokument exportieren.

\functionality{Exportieren der angezeigten Visualisierung in einem beliebigen Schritt als Grafik}{fnc:imageexport}
\fulfills{crt:imageexport}

Die aktuell angezeigte Visualisierung lässt sich als Bild im PNG- oder SVG-Format exportieren.

\functionality{Deaktivierung und Aktivierung der Standardbibliothek}{fnc:disablelib}
\fulfills{crt:disablelib}

Die Einbindung der Standardbibliothek kann über die Menüleiste deaktiviert und wieder aktiviert werden. Nach einer De- oder Aktivierung wird eine möglicherweise laufende Abfrage abgebrochen und die Konsole sowie das Visualisierungs-Fenster geleert. Das Prolog-Programm muss über die Parsen-Schaltfläche neu geparst werden.

\functionality{Formatierung des Quellcodes}{fnc:formatter}
\fulfills{crt:formatting}

Eine automatische Formatierung von korrektem Prolog-Quellcode ist über die Menüleiste möglich. Die Formatierung ist hierbei vorgegeben und kann nicht verändert werden. Schlägt die Formatierung fehl, so wird eine Fehlermeldung ausgegeben.

\functionality{Wechsel der verwendeten Sprache}{fnc:translation}
\fulfills{crt:translation}

Über die Menüleiste kann die Sprache der GUI-Elemente zwischen Englisch und Deutsch gewechselt werden. Dabei die Visualisierung in der entsprechenden Sprache neu generiert. Der Inhalt der Konsole wird geleert. Die Meldung \enquote{Die Sprache wurde gewechselt} wird in der entsprechenden Sprache in der Konsole ausgegeben. Die gewählte Sprache bleibt nach einem Neustart des Programms erhalten.

\functionality{Schnellzugriffsleiste}{fnc:buttons}
\fulfills{crt:buttons}

Die Leiste soll den Schnellzugriff auf wichtige Funktionen, wie z.B. das Parsen eines Prolog-Programms oder das Formatieren von Quellcode, über zusätzliche Schaltflächen ermöglichen.

\section{Nicht-Funktionale Anforderungen}

\nonFunctionality{Programmstart}{nfc:startup}

Das Programm startet auf einem modernen System innerhalb von 30 Sekunden und ist voll einsatzbereit.

\nonFunctionality{Dauer beim Parsen}{nfc:parsespeed}

Ein importiertes oder geschriebenes Prolog-Programm im Umfang von maximal 100 Zeilen Code ist innerhalb von maximal 3 Sekunden geparst.

\nonFunctionality{Dauer der Visualisierung}{nfc:visualizationspeed}

Ein Graph mit maximal 100 Knoten soll in maximal 10 Sekunden generiert sein.

\nonFunctionality{Design}{nfc:design}

Das Design wirkt modern und ansprechend.

\nonFunctionality{Ausführbarkeit}{nfc:installation}

Das Programm lässt sich ohne die manuelle Installation weiterer Programme durch das Ausführen einer .jar Datei starten.

\nonFunctionality{Programmgröße}{nfc:filesize}

Das Programm ist ohne Abhängigkeiten kleiner als 50 MiB, mit Abhängigkeiten kleiner als 200 MiB.

\nonFunctionality{Geschwindigkeit beim Öffnen eines Programms}{nfc:loadfile}

Das Öffnen einer Prolog-Programmdatei mit einer Größe von unter 1 MiB geschieht in unter 5 Sekunden.

\nonFunctionality{Robustheit}{nfc:crashresistance}

Fehlerhafte Prolog-Programme sollen nie zu einem Absturz des Programms führen.

\nonFunctionality{Erweiterbarkeit}{nfc:extendable}

Der Prolog-Interpreter lässt sich in seiner Funktionalität einfach erweitern, um weitere Sprachfeatures zu unterstützen.

\section{Tests}

\test{Öffnen einer Prolog-Programmdatei}{tst:open}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Es ist kein Prolog-Programm im Editor geöffnet.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Datei-Auswahl-Dialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über den Datei-Auswahl-Dialog ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche des Datei-Auswahl-Dialogs.}
{Der Datei-Auswahl-Dialog schließt sich. Die Datei wird im Editor-Fenster geöffnet.}

\test{Öffnen einer Prolog-Programmdatei und Speichern von vorhandenem Editor-Inhalt}{tst:openanother}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Im Editor wurde ein Prolog-Programm von Hand eingegeben.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Info-Dialog öffnet sich und fragt den Nutzer, ob das im Editor eingegebene Prolog-Programm gespeichert oder verworfen werden soll.}

\teststep{Der Nutzer hat die Wahl das im Editor geschriebene Prolog-Programm zu speichern oder zu verwerfen.}
{Der Nutzer betätigt die Speichern-Schaltfläche des Info-Dialogs.}
{Der Info-Dialog schließt sich und ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Speicherort und einen Dateinamen. Anschließend betätigt er die Speichern-Schaltfläche des Datei-Speichern-Dialogs.}
{Der Datei-Speichern-Dialog schließt sich. Ein Datei-Auswahl-Dialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über den Datei-Auswahl-Dialog ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche des Datei-Auswahl-Dialogs.}
{Der Datei-Auswahl-Dialog schließt sich. Die zu öffnende Datei wird in den Editor geladen und überschreibt den bisherigen Inhalt.}

\test{Öffnen einer Prolog-Programmdatei und Verwerfen von vorhandenem Editor-Inhalt}{tst:openanother2}
\tests{fnc:open}

\teststep{Das Programm wird ausgeführt. Im Editor wurde ein Prolog-Programm von Hand eingegeben.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Datei-Auswahl-Dialog öffnet sich.}

\teststep{Der Nutzer hat eine Datei über den Auswahl-Dialog ausgewählt.}
{Der Nutzer betätigt die Öffnen-Schaltfläche des Auswahl-Dialogs.}
{Der Datei-Auswahl-Dialog schließt sich. Ein Öffnen-Dialog öffnet sich und fragt den Nutzer, ob das im Editor eingegebene Prolog-Programm gespeichert oder verworfen werden soll.}

\teststep{Der Nutzer hat die Wahl, das im Editor geschriebene Prolog-Programm zu speichern oder zu verwerfen.}
{Der Nutzer betätigt die Verwerfen-Schaltfläche des Öffnen-Dialogs.}
{Der Öffnen-Dialog schließt sich. Das im Editor geöffnete Prolog-Programm wird verworfen. Die zu öffnende Datei wird in dem Editor geöffnet und überschreibt den bisherigen Inhalt.}

\test{Speichern eines im Editor geschrieben Prolog-Programmes}{tst:saveas}
\tests{fnc:saveas}

\teststep{Das Programm wird ausgeführt. Ein Prolog-Programm ist im Editor von Hand eingegeben worden.}
{Der Nutzer wählt über die Menüleiste die Speichern-als-Funktion aus.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Speicherort und Dateinamen aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Der Inhalt des Editors wird an den gewählten Ort geschrieben.}

\test{Speichern eines aus einer Datei geöffneten Prolog-Programmes}{tst:save}
\tests{fnc:save}

\teststep{Das Programm wird ausgeführt. Ein Prolog-Programm ist aus einer Datei geöffnet worden.}
{Der Nutzer wählt über die Menüleiste die Speichern-Funktion aus.}
{Der Inhalt des Editors wird an den gewählten Ort geschrieben.}

\test{Inkorrektes Prolog-Programm}{tst:errorcheck}
\tests{fnc:errorcheck}

\teststep{Der Nutzer hat das Prolog-Programm \texttt{father(} in den Editor eingetragen.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste, um das Prolog-Programm zu parsen.}
{Die Ausführung wird abgebrochen. Eine verständliche Fehlermeldung \enquote{Syntax-Fehler in Zeile 1} wird in der Konsole angezeigt.}

\test{Mehrere Ziele in der Abfrage}{tst:shell}
\tests{fnc:shell}

\teststep{Das \texttt{simpsons.pl}-Programm ist im Editor-Fenster eingegeben und erfolgreich geparst worden. Das Eingabefeld ist freigegeben.}
{Der Nutzer gibt die Abfrage \texttt{father(homer, X). mother(marge, X).} im Eingabefeld ein.}
{In der Konsole wird der Fehler \enquote{Nur ein Ziel in der Abfrage erlaubt.} ausgegeben und das Eingabefeld geleert.}

\test{Syntaktischer Fehler in der Abfrage}{tst:inputerror}
\tests{fnc:inputerror}

\teststep{Das \texttt{simpsons.pl}-Programm ist im Editor-Fenster eingegeben und erfolgreich geparst worden. Das Eingabefeld ist freigegeben.}
{Der Nutzer gibt die Abfrage \texttt{father(} ein.}
{In der Konsole wird der Fehler \enquote{Syntax-Fehler in Abfrage.} ausgegeben und das Eingabefeld geleert.}

\test{Interpretierung vom simpsons.pl-Programm}{tst:simpsons}
\tests{fnc:interpreter}

\teststep{Das \texttt{simpsons.pl}-Programm ist im Editor-Fenster eingegeben worden.}
{Der Nutzer betätigt die Parsen-Schaltfläche des Hauptfensters.}
{Das Prolog-Programm wird erfolgreich geparst, es kommt zu keinen Fehlern. In das Eingabefeld kann eine Abfrage eingegeben werden.}

\teststep{Das Prolog-Programm wurde geparst. In das Eingabefeld kann eine Abfrage eingegeben werden.}
{Der Nutzer gibt die Abfrage \texttt{father(X, bart).} in das Eingabefeld ein.}
{Das Prolog-Programm wird interpretiert und die Wurzel des generierten Graphen wird angezeigt.}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
    \includegraphics[width=0.7\linewidth]{build/visualisation/test_father_root.png}}
\captionof{figure}{Wurzel der Abfrage \texttt{father(X, bart)}}
\end{minipage}

\test{Interaktive Nutzung des Interpreters}{tst:ask}
\tests{fnc:interpreter}
\tests{fnc:interpreterforward}
\tests{fnc:interpreteroutput}

\teststep{Der Nutzer hat das korrekte Prolog-Programm \texttt{father(homer, bart). father(homer, lisa).} im Editor eingegeben.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{In der Konsole wird eine Erfolgsnachricht ausgegeben.}

\teststep{Das Eingabefeld erwartet eine Abfrage.}
{Der Nutzer gibt die Abfrage \texttt{father(homer, X).} ein und bestätigt die Eingabe.}
{Die Interpretation wird gestartet und der erste Interpretationsschritt wird visualisiert.}

\teststep{Der erste Interpretationsschritt ist visualisiert.}
{Der Nutzer betätigt die Schritt-Schaltfläche bis eine Lösung gefunden wurde.}
{Zwischenschritte werden visualisiert. In der Konsole erscheint die erste Lösung \texttt{X = bart }.}

\test{Ausführen arithmetischer Operationen}{tst:maths}
\tests{fnc:maths}

Prolog-Programm für Arithmetik:
\phantomsection
\label{tst:maths_prog}
\begin{lstlisting}
A is 1 + 3 - 2.
B is 2 * 3.
C = 6 + 1.
\end{lstlisting}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Das \hyperref[tst:maths_prog]{Prolog-Programm für Arithmetik} ist geöffnet.}
{Der Nutzer gibt die Abfrage \texttt{A is 4.} ein.}
{In der Konsole erscheint \texttt{no .}}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Das \hyperref[tst:maths_prog]{Prolog-Programm für Arithmetik} ist geöffnet.}
{Der Nutzer gibt die Abfrage \texttt{B is 6.} ein.}
{In der Konsole erscheint \texttt{yes}}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Das \hyperref[tst:maths_prog]{Prolog-Programm für Arithmetik} ist geöffnet.}
{Der Nutzer gibt die Abfrage \texttt{C is 6 + 1.} ein.}
{In der Konsole erscheint \texttt{no .}}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Das \hyperref[tst:maths_prog]{Prolog-Programm für Arithmetik} ist geöffnet.}
{Der Nutzer gibt die Abfrage \texttt{C = 6 + 1.} ein.}
{In der Konsole erscheint \texttt{yes}}

\test{Cut-Funktionalität}{tst:cut}
\tests{fnc:cut}

Prolog-Programm für Cut:
\phantomsection
\label{tst:cut_prog}
\begin{lstlisting}
max(X, Y, X) :- X > Y, !.
max(X, Y, Y).
\end{lstlisting}

\teststep{Das Programm wird ausgeführt und ist fokussiert. Das \hyperref[tst:cut_prog]{Prolog-Programm für Cut} ist geöffnet.}
{Der Nutzer gibt die Abfrage \texttt{max(42, 17, X).} ein.}
{In der Konsole erscheint die Lösung \texttt{X = 42}.}

\test{Aktivieren der Standardbibliothek}{tst:enablelib}
\tests{fnc:disablelib}

\teststep{Das Programm ist geöffnet und fokussiert. Der Editor ist leer. Die Standardbibliothek ist nicht aktiviert.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{Das leere Prolog-Programm wird erfolgreich geparst.}

\teststep{Das Parsen des Prolog-Programms war erfolgreich. Das Eingabefeld ist freigeschaltet.}
{Der Nutzer gibt die Abfrage \texttt{append([1], [2], X).} in das Eingabefeld ein und bestätigt mit der Eingabe-Taste.}
{Die Abfrage wird interpretiert und die Wurzel des Graphen angezeigt.}

\teststep{Die Wurzel des Graphen wird angezeigt.}
{Der Nutzer betätigt die \enquote{Nächste Lösung}-Schaltfläche.}
{In der Visualisierung wird \enquote{Nicht erfüllbar!} angezeigt. Die Konsole zeigt \enquote{\texttt{no .}} an.}

\teststep{Die Visualisierung wird angezeigt.}
{Der Nutzer setzt den Haken bei der \enquote{Standardbibliothek laden}-Schaltfläche in der Menüleiste.}
{Die Standardbibliothek ist nun aktiviert. Die Visualisierung und der Inhalt der Konsole werden verworfen.}

\teststep{Die Standardbibliothek ist aktiviert.}
{Der Nutzer betätigt erneut die Parsen-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird erfolgreich geparst.}

\teststep{Das Parsen des Prolog-Programms war erfolgreich. Das Eingabefeld ist freigeschaltet.}
{Der Nutzer gibt die Abfrage \texttt{append([1], [2], X).} in das Eingabefeld ein und bestätigt mit der Eingabe-Taste.}
{Die Abfrage wird interpretiert und die Wurzel des Graphen angezeigt.}

\teststep{Die Wurzel des Graphen wird angezeigt.}
{Der Nutzer betätigt die \enquote{Nächste Lösung}-Schaltfläche.}
{Die nächste Lösung wird erfolgreich in der Visualisierung angezeigt. In der Konsole erscheint die Lösung \texttt{X = [1, 2]}.}

\test{Zoomen innerhalb der Visualisierung}{tst:zoom}
\tests{fnc:zoom}

\teststep{Eine Abfrage ist visualisiert. Der Mauszeiger befindet sich im Visualisierungs-Fenster.}
{Der Nutzer bewegt das Mausrad zu sich bzw. nach hinten.}
{Es wird aus der Visualisierung heraus gezoomt.}

\teststep{Eine Abfrage ist visualisiert. Der Mauszeiger befindet sich im Visualisierungs-Fenster.}
{Der Nutzer bewegt das Mausrad von sich weg bzw. nach vorne.}
{Es wird in die Visualisierung herein gezoomt.}

\test{Bewegung innerhalb der Visualisierung}{tst:move}
\tests{fnc:move}

\teststep{Eine Abfrage ist visualisiert. Der Mauszeiger befindet sich im Visualisierungs-Fenster.}
{Der Nutzer hält die linke Maustaste gedrückt und bewegt die Maus.}
{Der angezeigte Ausschnitt bewegt sich passend zu der Mausbewegung.}

\test{Formatierung von Quellcode}{tst:formatter}
\tests{fnc:formatter}

\teststep{Der Nutzer hat das unformatierte \texttt{simpsons.pl}-Programm im Editor eingegeben oder aus einer Datei geöffnet.}
{Der Nutzer betätigt die Formatieren-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird automatisch formatiert. Der Editor zeigt nun das formatierte \texttt{simpsons.pl}-Programm an.}

\test{Export als Bilddatei}{tst:latexexport}
\tests{fnc:imageexport}

\teststep{Das \texttt{simpsons.pl}-Beispielprogramm ist im Editor eingegeben und der unten gezeigte Zustand wurde erreicht und visualisiert.}
{Der Nutzer wählt über die Menüleiste die Exportieren-als-Bild-Funktion aus.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Dateinamen, ein Zielverzeichnis und den Dateityp PNG aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Die Visualisierung wird als PNG-Datei im Zielverzeichnis gespeichert. Die Dateiendung \texttt{.png} wird wenn nötig ergänzt.}

\test{Export als LaTeX für Foliensätze}{tst:latexexporttikz}
\tests{fnc:latexexport}

\teststep{Das \texttt{simpsons.pl}-Beispielprogramm ist im Editor eingegeben und der unten gezeigte Zustand wurde erreicht und visualisiert.}
{Der Nutzer wählt über die Menüleiste die Exportieren-als-TikZ-Funktion aus.}
{Ein Datei-Speichern-Dialog öffnet sich.}

\teststep{Ein Datei-Speichern-Dialog ist geöffnet.}
{Der Nutzer wählt einen Dateinamen und ein Zielverzeichnis aus. Anschließend betätigt er die Speichern-Schaltfläche.}
{Die Visualisierung wird als TikZ-Datei im Zielverzeichnis gespeichert. Die Dateiendung \texttt{.tikz} wird wenn nötig ergänzt.}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/visualisation/12_first_solution.png}
}
\captionof{figure}{Die zu exportierende Visualisierung}
\end{minipage}

\test{Visualisierung fehlgeschlagener Unifikation}{tst:unificationfail}
\tests{fnc:unificationfail}

\teststep{Das \texttt{simpsons.pl}-Beispielprogramm ist im Editor eingegeben und durch den Parser verarbeitet worden. Der Nutzer hat die Abfrage \texttt{father(homer, X)} eingegeben. Die Interpretation wird gestartet und die Visualisierung des ersten Interpretationsschritts wird angezeigt.}
{Der Nutzer betätigt die Schaltfläche \enquote{Nächster Schritt}.}
{Eine fehlgeschlagene Unifikation mit \texttt{father(abe, homer)} wird entsprechend der gezeigten Grafik visualisiert.}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=0.7\linewidth]{build/visualisation/tst_unification_fail.png}
}
\captionof{figure}{Zustand nach einem Schritt: fehlgeschlagene Unifikation}
\end{minipage}

\test{Visualisierung erfolgreicher Unifikation}{tst:unificationsuccess}
\tests{fnc:unificationsuccess}

\teststep{Das \texttt{simpsons.pl}-Beispielprogramm ist im Editor eingegeben und durch den Parser verarbeitet worden. Der Nutzer hat die Abfrage \texttt{father(homer, X)} eingegeben. Die Interpretation wird gestartet und die Visualisierung des ersten Interpretationsschritts wird angezeigt.}
{Der Nutzer betätigt die Schaltfläche \enquote{Nächster Schritt} zwei mal.}
{Eine erfolgreiche Unifikation mit \texttt{father(homer, bart)} wird entsprechend der gezeigten Grafik visualisiert.}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=0.7\linewidth]{build/visualisation/tst_unification_success.png}
}
\captionof{figure}{Zustand nach zwei Schritten: erfolgreiche Unifikation}
\end{minipage}

\test{Visualisierung von Backtracking}{tst:backtracking}
\tests{fnc:backtracking}

\teststep{Das \texttt{simpsons.pl}-Beispielprogramm ist im Editor eingegeben und durch den Parser verarbeitet worden. Der Nutzer hat die Abfrage \texttt{father(homer, X)} eingegeben. Die Interpretation wird gestartet und die Visualisierung des ersten Interpretationsschritts wird angezeigt.}
{Der Nutzer betätigt die Schaltfläche \enquote{Nächster Schritt}.}
{Eine fehlgeschlagene Unifikation wird analog zu Abbildung 3 in Test \enquote{Visualisierung fehlgeschlagener Unifikation} visualisiert.}

%TODO Abbildung Backtracking

\teststep{Die fehlgeschlagene Unifikation wird visualisiert.}
{Der Nutzer betätigt die Schaltfläche \enquote{Nächster Schritt}.}
{Das Backtracking zum Testen der nächsten Belegung wird visualisiert.}

\test{Wechsel der GUI-Sprache}{tst:language}
\tests{fnc:translation}

\teststep{Das Programm ist geöffnet und auf die Sprache Deutsch eingestellt.}
{Der Nutzer wählt in der Menüleiste die Sprache \enquote{Englisch} aus.}
{Die Sprache aller GUI-Elemente ändert sich auf die Sprache Englisch. Der Inhalt der Konsole wird gelöscht, alle zukünftigen Ausgaben bis zu einem erneuten Sprachwechsel erscheinen in Englisch.}

\teststep{Das Programm ist geöffnet und auf die Sprache Englisch eingestellt.}
{Der Nutzer beendet das Programm und startet es erneut.}
{Das Programm ist geöffnet, die GUI Sprache ist immernoch auf Englisch eingestellt.}

\teststep{Die Sprache der GUI ist auf Englisch eingestellt.}
{Der Nutzer wählt in der Menüleiste die Sprache \enquote{Deutsch} aus.}
{Die Sprache aller GUI-Elemente ändert sich auf die Sprache Deutsch. Der Inhalt der Konsole wird gelöscht, alle zukünftigen Ausgaben bis zu einem erneuten Sprachwechsel erscheinen in Deutsch.}

\section{Systemtests}

\test{Erstellung, Bearbeitung, Speichern und Parsen des simpsons.pl-Programms}{tst:sys1}
\tests{fnc:new}
\tests{fnc:editor}
\tests{fnc:formatter}
\tests{fnc:save}
\tests{fnc:parser}
\tests{fnc:errorcheck}

\teststep{Der Nutzer hat ein leeres Editor-Fenster vor sich.}
{Der Nutzer gibt das unformatierte \texttt{simpsons.pl}-Programm wie im Anhang beschrieben ein.}
{Der Inhalt des Editors wird entsprechend der Eingabe geändert.}

\teststep{Das unformatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen.}
{Der Nutzer betätigt die Formatieren-Funktion in der Menüleiste.}
{Das \texttt{simpsons.pl}-Programm wird formatiert und entspricht dem formatierten \texttt{simpsons.pl}-Programm im Anhang.}

\teststep{Das formatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen.}
{Der Nutzer wählt über die Menüleiste die Speichern-Funktion aus.}
{Ein Speichern-Dialog öffnet sich.}

\teststep{Der Nutzer hat über den Speichern-Dialog ein Verzeichnis sowie einen Dateinamen eingetragen.}
{Der Nutzer betätigt die Speichern-Schaltfläche.}
{Das Prolog-Programm wird im gewählten Verzeichnis gespeichert.}

\teststep{Das formatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen und gespeichert.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird erfolgreich geparst. Es werden keine Fehlermeldungen ausgegeben. Das Eingabefeld wird freigegeben.}

\teststep{Das formatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen, gespeichert und durch den Parser verarbeitet worden.}
{Der Nutzer fokussiert durch einen Mausklick das Editor-Fenster und fügt vor die erste Zeile das Wort \enquote{Fehler(}, gefolgt von einem Umbruch ein.}
{Das Eingabefeld wird gesperrt.}

\teststep{Das unformatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen und gespeichert worden. Das Wort \enquote{Fehler(} wurde vor die ursprüngliche erste Zeile eingetragen.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{Das Eingabefeld bleibt weiterhin gesperrt. Der Parser gibt über die Konsole die folgende Fehlermeldung aus: \texttt{Parser-Fehler in Zeile 1. Erwartete \enquote{)} oder Identifier oder Variable statt \enquote{EOF} nach \enquote{Fehler(}}}

\test{Öffnen eines Prolog-Programms, Parsen, Eingabe einer Abfrage und Interpretation}{tst:sys2}
\tests{fnc:open}
\tests{fnc:parser}
\tests{fnc:shell}
\tests{fnc:interpreter}
\tests{fnc:visualization}

\teststep{Der Nutzer hat das Programm geöffnet.}
{Der Nutzer wählt über die Menüleiste die Öffnen-Funktion aus.}
{Ein Öffnen-Dialog erscheint.}

\teststep{Der Nutzer hat ein Prolog-Programm ausgewählt, welches das formatierte \texttt{simpsons.pl}-Programm enthält.}
{Der Nutzer betätigt die Öffnen-Schaltfläche in der Menüleiste.}
{Der Editor enthält die formatierte \texttt{simpsons.pl}-Programmdatei.}

\teststep{Der Editor enthält die formatierte \texttt{simpsons.pl}-Programmdatei.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird erfolgreich geparst. Es werden keine Fehlermeldungen ausgegeben. Das Eingabefeld wird freigegeben.}

\teststep{Das Prolog-Programm wurde erfolgreich geparst. Es wurden keine Fehlermeldungen ausgegeben.}
{Der Nutzer gibt im Eingabefeld \texttt{mother(marge, bart).} ein und bestätigt mit der Eingabe-Taste.}
{Der Parser verarbeitet die Abfrage korrekt. Die Interpretation wird gestartet und der erste Interpretationsschritt wird visualisiert.}

\teststep{Der Interpreter ist beim ersten Schritt der Interpretation der gegebenen Abfrage. Eine Visualisierung wird angezeigt.}
{Der Nutzer betätigt die Schritt-Schaltfläche bis eine Lösung gefunden wird.}
{Eine Lösung wurde gefunden. Es wird \texttt{yes} in der Konsole ausgegeben.}

\test{Öffnen eines zuletzt verwendeten Prolog-Programms, Parsen und Interpretieren einer Abfrage, Ausführung bis zur nächsten Ausgabe und Abbruch}{tst:sys3}
\tests{fnc:recentfiles}
\tests{fnc:parser}
\tests{fnc:shell}
\tests{fnc:interpreter}
\tests{fnc:visualization}
\tests{fnc:continue}
\tests{fnc:cancel}

\teststep{Der Nutzer hat das Programm nach dem Speichern des \texttt{simpsons.pl}-Programms im Anhang neu gestartet.}
{Der Nutzer wählt das \texttt{simpsons.pl}-Programm über die Menüleiste unter \enquote{Kürzlich geöffnete Dateien} aus.}
{Das \texttt{simpsons.pl}-Programm wird im Editor geöffnet.}

\teststep{Der Editor enthält die formatierte \texttt{simpsons.pl}-Programmdatei analog zum Anhang.}
{Der Nutzer betätigt die Parsen-Schaltfläche in der Menüleiste.}
{Das Prolog-Programm wird erfolgreich geparst. Es werden keine Fehlermeldungen ausgegeben. Das Eingabefeld wird freigegeben.}

\teststep{Das Prolog-Programm wurde erfolgreich geparst. Es wurden keine Fehlermeldungen ausgegeben.}
{Der Nutzer gibt im Eingabefeld \texttt{mother(X, bart).} ein und bestätigt mit der Eingabe-Taste.}
{Der Parser verarbeitet die Abfrage korrekt. Die Interpretation wird gestartet und der erste Interpretationsschritt wird visualisiert.}

\teststep{Der Interpreter ist beim ersten Schritt der Interpretation der gegebenen Abfrage. Eine Visualisierung dieses Schritts wird angezeigt.}
{Der Nutzer betätigt die Nächste-Lösung-Schaltfläche.}
{Die Interpretation wird bis zur Findung einer Lösung fortgeführt. Es wird \texttt{X = marge} ausgegeben. Die Visualisierung entspricht der Visualisierung bei der Findung der ersten Lösung.}

\teststep{Der Interpreter hat eine erste Lösung gefunden. Die Visualisierung ist aktualisiert worden.}
{Der Nutzer betätigt die Nächste-Lösung-Schaltfläche erneut.}
{Der Interpreter wird bis zur Findung einer weiteren Lösung fortgeführt.}

\teststep{Der Interpreter versucht, eine weitere Lösung für die Abfrage zu finden.}
{Der Nutzer betätigt die Abbrechen-Schaltfläche.}
{Die Interpretation wird abgebrochen.}

\test{Interpretieren einer Abfrage, Ausführung bis zur nächsten Lösung, Navigation der Visualisierung, Zurückschreiten und Exportieren}{tst:sys4}
\tests{fnc:interpreter}
\tests{fnc:visualization}
\tests{fnc:continue}
\tests{fnc:stepback}
\tests{fnc:move}
\tests{fnc:zoom}
\tests{fnc:imageexport}
\tests{fnc:latexexport}

\teststep{Der Nutzer hat das formatierte \texttt{simpsons.pl}-Programm aus dem Anhang im Editor eingetragen, durch den Parser verarbeiten lassen und die Abfrage \texttt{mother(X, bart).} gestellt. Der Interpreter ist beim ersten Schritt der Interpretation der gegebenen Abfrage. Eine Visualisierung dieses Schritts wird angezeigt.}
{Der Nutzer betätigt die Nächster-Schritt-Schaltfläche.}
{Die Interpretation wird bis zur Findung einer Lösung fortgeführt. Es wird \texttt{X = marge} ausgegeben. Die Visualisierung entspricht der Visualisierung bei der Findung der ersten Lösung.}

\teststep{Die Visualisierung entspricht dem Zustand, bei dem die Lösung \texttt{X = marge} gefunden wurde.}
{Der Nutzer hält innerhalb der Visualisierung die linke Maustaste gedrückt und bewegt die Maus nach links.}
{Der angezeigte Ausschnitt der Visualisierung bewegt sich nach links.}

\teststep{Die Visualisierung entspricht dem Zustand, bei dem die Lösung \texttt{X = marge} gefunden wurde. Die Visualisierung wurde nach links verschoben.}
{Der Nutzer betätigt die \enquote{+}-Schaltfläche.}
{Es wird in den angezeigten Ausschnitt der Visualisierung hineingezoomt.}

\teststep{Die Visualisierung entspricht dem Zustand, bei dem die Lösung \texttt{X = marge} gefunden wurde. Es wurde in die nach links verschobene Visualisierung hineingezoomt.}
{Der Nutzer wählt über die Menüleiste die Option \enquote{Exportieren als Bild} aus.}
{Ein Speichern-Dialog öffnet sich.}

\teststep{Der Nutzer hat über die Auswahl des Speichern-Dialogs zwischen dem Format PNG und SVG ausgewählt. Ein Verzeichnis wurde ausgewählt.}
{Der Nutzer betätigt die Speichern-Schaltfläche.}
{Die gesamte Visualisierung wird im ausgewählten Format gespeichert.}

\teststep{Die Visualisierung entspricht dem Zustand, bei dem die Lösung \texttt{X = marge} gefunden wurde. Es wurde in die nach links verschobene Visualisierung hineingezoomt. Die Visualisierung wurde bereits als Bild-Datei exporiert.}
{Der Nutzer wählt über die Menüleiste die Option \enquote{Exportieren als TikZ} aus.}
{Ein Speichern-Dialog öffnet sich.}

\teststep{Der Nutzer hat das Zielverzeichnis über die Auswahl des Speichern-Dialogs ausgewählt.}
{Der Nutzer betätigt die Speichern-Schaltfläche.}
{Die gesamte Visualisierung wird als LaTeX-Quellcode gespeichert.}

\test{Schnellzugriffsleiste}{tst:sys_buttonbar}
\tests{fnc:new}
\tests{fnc:open}
\tests{fnc:formatter}
\tests{fnc:save}
\tests{fnc:parser}
\tests{fnc:interpreter}
\tests{fnc:visualization}
\tests{fnc:continue}
\tests{fnc:buttons}

\teststep{Der Nutzer hat das formatierte \texttt{simpsons.pl}-Programm im Editor eingetragen.}
{Der Nutzer betätigt die Erstellen-Schaltfläche der Schnellzugriffsleiste.}
{Der Inhalt des Editors ist leer.}

\teststep{Der Inhalt des Editors ist leer.}
{Der Nutzer betätigt die Öffnen-Schaltfläche der Schnellzugriffsleiste.}
{Ein Öffnen-Dialog erscheint.}

\teststep{Der Nutzer hat über den Öffnen-Dialog eine Datei ausgewählt, welche das unformatierte \texttt{simpsons.pl}-Programm enthält.}
{Der Nutzer betätigt die Öffnen-Schaltfläche des Öffnen-Dialogs.}
{Der Editor enthält das unformatierte \texttt{simpsons.pl}-Programm.}

\teststep{Das unformatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen.}
{Der Nutzer betätigt die Formatieren-Schaltfläche der Schnellzugriffsleiste.}
{Der Editor enthält das formatierte \texttt{simpsons.pl}-Programm.}

\teststep{Das formatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen.}
{Der Nutzer betätigt die Speichern-Schaltfläche der Schnellzugriffsleiste.}
{Ein Speichern-Dialog öffnet sich}

\teststep{Der Nutzer hat über den Speichern-Dialog ein Verzeichnis und einen Dateinamen eingetragen.}
{Der Nutzer betätigt die Speichern-Schaltfläche des Dialogs.}
{Das Prolog-Programm wird im gewählten Verzeichnis gespeichert.}

\teststep{Das formatierte \texttt{simpsons.pl}-Programm ist im Editor eingetragen und gespeichert.}
{Der Nutzer betätigt die Parsen-Schaltfläche der Schnellzugriffsleiste.}
{Das Prolog-Programm wird erfolgreich geparst. Es werden keine Fehlermeldungen ausgegeben. Das Eingabefeld wird freigegeben.}

\teststep{Das Prolog-Programm wurde erfolgreich geparst.}
{Der Nutzer gibt im Eingabefeld \texttt{father(homer, X).} ein und bestätigt mit der Eingabe-Taste.}
{Der Parser verarbeitet die Abfrage korrekt. Die Interpretation wird gestartet und der erste Interpretationsschritt wird visualisiert.}

\teststep{Der Interpreter ist beim ersten Schritt der Interpretation der gegebenen Abfrage. Eine Visualisierung dieses Schritts wird angezeigt.}
{Der Nutzer betätigt die Nächster Schritt-Schaltfläche der Schnellzugriffsleiste.}
{Die Interpretation wird um einen Schritt fortgeführt. Die Visualierung befindet sich im Zustand des nächsten Schrittes.}

\teststep{Die Visualisierung befindet sich im Zustand des zweiten Schrittes.}
{Der Nutzer betätigt die Nächste-Lösung-Schaltfläche der Schnellzugriffsleiste.}
{Die Interpretation wird bis zur nächsten Lösung fortgeführt. Es wird \texttt{X = bart} ausgegeben. Die Visualisierung entspricht der Visualisierung bei der Findung der ersten Lösung.}

\appendix

\section{GUI-Entwürfe}

\subsection{Musskriterien}

Die folgenden Entwürfe beinhalten alle Musskriterien.

\subsubsection{Programmstart}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
    \includegraphics[width=\linewidth]{build/gui/main_view_initial.png}}
\captionof{figure}{Hauptfenster unmittelbar nach dem Starten des Programms}
\end{minipage}

Das Hauptfenster besteht aus der Fensterleiste (A), der Menüleiste (1), dem Editor (2), der Visualisierungsbox (3), der Konsole (4) und dem Eingabefeld (5).
Dabei ist die Fensterleiste kein Bestandteil des Programms; sie ist von der grafischen Oberfläche des Betriebssystems vorgegeben.
Das Eingabefeld ist gesperrt (angedeutet durch die graue Färbung), da noch kein Prolog-Programm geparst wurde.

\subsubsection{\enquote{Datei}-Menü}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
    \includegraphics[width=\linewidth]{build/gui/main_view_filemenu.png}}
\captionof{figure}{Hauptfenster mit ausgewähltem \enquote{Datei}-Menü}
\end{minipage}

Das \enquote{Datei}-Menü (1) hat die Einträge \enquote{Neu}, \enquote{Öffnen}, \enquote{Speichern}, \enquote{Speichern als...}, \enquote{Zuletzt verwendet} und \enquote{Beenden}.
\enquote{Neu}, \enquote{Öffnen} und \enquote{Speichern} führen die jeweiligen Funktionen aus.
Während \enquote{Speichern} nur bei neu angelegten Prolog-Programmen einen Auswahl-Dialog anzeigt, zeigt \enquote{Speichern als...} immer einen Auswahl-Dialog an.
\enquote{Beenden} beendet das Programm.
\enquote{Zuletzt verwendet} enthält eine Liste von bis zu fünf zuletzt verwendeten Programmen (2).

\subsubsection{Geöffnete Datei}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
    \includegraphics[width=\linewidth]{build/gui/main_view_opened.png}}
\captionof{figure}{Hauptfenster nach dem Öffnen des Beispielprogramms}
\end{minipage}

Nach dem Öffnen des Beispielprogramms wird dessen Inhalt im Editor angezeigt (1).
Die Konsole gibt eine entsprechende Meldung aus (2).
Das Eingabefeld bleibt weiterhin gesperrt (3).

\subsubsection{Parsen fehlgeschlagen}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
    \includegraphics[width=\linewidth]{build/gui/main_view_parse_fail.png}
}
\captionof{figure}{Hauptfenster nach Klick auf \enquote{Parsen}, mit inkorrektem Prolog-Programm}
\end{minipage}

Klickt der Nutzer auf \enquote{Parsen} im \enquote{Programm}-Menü (1), versucht der Parser das Prolog-Programm im Editor zu verarbeiten.
Stößt er dabei auf Fehler, wird eine Fehlermeldung in der Konsole angezeigt (2).
Das Eingabefeld bleibt weiterhin gesperrt (3).

\subsubsection{Parsen erfolgreich}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_parse_success.png}
}
\captionof{figure}{Hauptfenster nach Klick auf \enquote{Parsen}, mit korrektem Prolog-Programm}
\end{minipage}

Klickt der Nutzer auf \enquote{Parsen} (1), versucht der Parser das Prolog-Programm im Editor zu verarbeiten.
Treten dabei keine Fehler auf, wird eine entsprechende Meldung in der Konsole angezeigt (2).
Das Eingabefeld wird freigegeben; der Nutzer kann jetzt Abfragen eingeben (3).

\subsection{Inkorrekte Abfrage}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_question_fail.png}
}
\captionof{figure}{Hauptfenster nach inkorrekter Abfrage im Eingabefeld}
\end{minipage}

Gibt der Nutzer eine Abfrage im Eingabefeld ein (1), versucht der Parser, diese Eingabe zu einem einzelnen Ziel zu verarbeiten.
Stößt er dabei auf Fehler, wird eine Fehlermeldung in der Konsole angezeigt (2).

\subsubsection{Erfolgreiche Abfrage}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_visualisation_root.png}
}
\captionof{figure}{Hauptfenster nach Eingabe einer Abfrage}
\end{minipage}

Gibt der Nutzer eine Abfrage (1) im Eingabefeld ein, versucht der Parser, diese Eingabe zu einem einzelnen Ziel zu verarbeiten.
Treten dabei keine Fehler auf, wird eine Meldung in der Konsole angezeigt (2) und die Visualisierung der Abarbeitung dieser Abfrage gestartet (3).
Eine Leiste mit Schaltflächen, die zur Steuerung der Visualisierung dienen, wird angezeigt.
Die Schaltfäche \enquote{Nächster Schritt} (4) bewirkt die Ausführung und Visualisierung des nächsten Schrittes.
Die Schaltflächen \enquote{+} und \enquote{-} (5) dienen zum Zoomen in der Visualisierung.

\subsubsection{Lösung gefunden}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_solution_found.png}
}
\captionof{figure}{Eine Lösung wurde gefunden}
\end{minipage}

Wurde ein Lösung für die Abfrage gefunden (1), wird eine Meldung in der Konsole angezeigt (2).

\subsubsection{Keine weiteren Lösungen}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_no_more_solutions.png}
}
\captionof{figure}{Es gibt keine weiteren Lösungen mehr}
\end{minipage}

Gibt es keine weiteren Lösungen mehr, wird eine Meldung (1) in der Konsole angezeigt und die Schaltfläche \enquote{Nächster Schritt} wird gesperrt (2).

Dieser Fall tritt ein, wenn der Interpreter einen Backtrack vom eingegeben Ziel auszuführen versucht.
In diesem Fall gibt es keine Fakten mehr, die mit dem Ziel unifizierbar sind.
Unabhängig davon, ob es per se keine Lösungen gibt oder schon Lösungen gefunden wurden, wird die Meldung \enquote{Keine weiteren Lösungen.} in der Konsole angezeigt.

In diesem Entwurf ist außerdem der Scrollbalken gezeigt (3).
Dieser wird neben der Konsole eingeblendet, wenn der angezeigte Text nicht mehr hineinpasst.
Dies gilt auch für den Editor.

\subsection{Kannkriterien}

Jeder der folgenden Entwürfe beinhaltet \emph{ein} Kannkriterium.

\subsubsection{Schaltfläche \enquote{Vorheriger Schritt}}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_previous_step.png}
}
    \captionof{figure}{Die Schaltfläche \enquote{vorheriger Schritt}}
\end{minipage}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_previous_step_disabled.png}
}
\captionof{figure}{Interpreter beim ersten Schritt; die Schaltfläche \enquote{Vorheriger Schritt} ist gesperrt}
\end{minipage}

Die Schaltfläche \enquote{Vorheriger Schritt} (1) erlaubt es dem Nutzer, den Zustand vor dem aktuellen Schritt zu betrachten.
Die Schaltfläche kann so lange betätigt werden, bis der Nutzer beim ersten Schritt angelangt ist.
Ist der Nutzer beim ersten Schritt angelangt, wird die Schaltfläche gesperrt.

\subsubsection{Ausführung bis zur nächsten Lösung}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_next_solution.png}
}
\captionof{figure}{Die Schaltfläche \enquote{Nächste Lösung}}
\end{minipage}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_abort.png}
}
\captionof{figure}{Die Schaltfläche \enquote{Abbrechen}}
\end{minipage}

Die Schaltfläche \enquote{Nächste Lösung} (1) lässt den Interpreter automatisch Schritte ausführen, bis eine Lösung gefunden wurde oder keine Unifikation der Abfrage mehr möglich ist.
Betätigt der Nutzer die Schaltfläche, wird sie hervorgehoben und ihr Text in \enquote{Abbrechen} geändert.
Betätigt der Nutzer die Schaltfläche erneut, wird der Interpreter nach der aktuellen Berechnung unterbrochen und der resultierende Zustand wird visualisiert.

\subsubsection{Export der Visualisierung}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_exportmenu.png}
}
\captionof{figure}{Die Schaltflächen \enquote{Exportieren...}}
\end{minipage}

Die Schaltflächen \enquote{Exportieren als Bild} und \enquote{Exportieren als TikZ} erlauben dem Nutzer das Exportieren der Visualisierung in verschiedenen Formaten (1).
\enquote{Exportieren als Bild} lässt den Nutzer zwischen dem Export als SVG- oder PNG-Grafik wählen.
\enquote{Exportieren als TikZ} lässt den Nutzer eine TeX-Datei mit einer Umsetzung der Visualisierung als TikZ-Grafik erstellen.

\subsubsection{Formatieren eines Prolog-Programms}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_format_button.png}
}
\captionof{figure}{Programm nach dem Betätigen der \enquote{Formatieren}-Schaltflfäche}
\end{minipage}

Wenn der Nutzer die Schaltfläche \enquote{Formatieren} betätigt, versucht das Programm, das Prolog-Programm im Editor nach den vorgegegeben Regeln zu formatieren.
Ist dies erfolgreich, wird eine Meldung auf der Konsole ausgegeben (2) und der Inhalt des Editors mit dem formatierten Prolog-Programm überschrieben (3).

Schlägt die Formatierung fehl, wird eine Fehlermeldung auf der Konsole ausgegeben.

\subsubsection{Schnellzugriffsleiste}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_buttonbar.png}
}
\captionof{figure}{Position der Schnellzugriffsleiste}
\end{minipage}

Die Schnellzugriffleiste bietet dem Nutzer die wichtigsten Funktionen an einem Ort.
Diese werden durch Schaltflächen mit Symbolen repräsentiert.
Die Symbole stehen für das Erstellen, Öffnen und Speichern von Dateien (1), Parsen und Formatieren von Prolog-Programmen (2) und \enquote{Ausführung eines Einzelschritts} sowie \enquote{Ausführung bis zur nächsten Lösung} (3).
Die Schaltflächen sind dabei nur freigegeben, wenn auch ihre Gegenstücke an anderen Stellen in der GUI freigegeben sind.
Im gezeigten Zustand sind die Schrittschaltflächen gesperrt, da kein Prolog-Programm erfolgreich geparst wurde.

\subsubsection{Einstellungen}

Manche Kannkriterien lassen den Nutzer allgemeine Einstellungen für das Verhalten des Programms festlegen.
Für solche Einstellungen wird ein Eintrag zur Menüleiste hinzugefügt.

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/gui/main_view_preferences.png}
}
\captionof{figure}{Das Einstellungsmenü mit Sprachauswahl}
\end{minipage}

Der Eintrag \enquote{Standardbibliothek laden} (1) lässt den Nutzer festlegen, ob vor der Interpretation einer Abfrage die Standardbibliothek geladen werden soll.

Der Eintrag \enquote{Sprache} (2) lässt den Nutzer die Sprache der GUI ändern.

\subsection{Visualisierung}

Um die Visualisierungsbeispiele besser darstellen zu können, wurden sie hier ohne die grafische Oberfläche des Programms eingefügt.
Die visualisierte Abfrage ist \texttt{grandfather(X, Y)} im \texttt{simpsons.pl}-Programm.

\subsubsection{Wurzel}

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=0.7\linewidth]{build/visualisation/01_root.png}
}
\captionof{figure}{Visualisierung des ersten Interpretationsschritts}
\end{minipage}

Die Visualisierung des ersten Interpretationsschritts stellt die eingegebene Abfrage dar.

\subsubsection{Erfolgreiche Unifikation und Teilziele}

Die erste Regel mit zu \texttt{grandfather(X, Y)} passendem Funktornamen ist auch die einzige, in Zeile 6.
Die Unifikation mit dieser Regel ist erfolgreich.
Dabei werden die Variablennamen durch neue, eindeutige Namen ersetzt um Konflikte zu vermeiden.
Der neue Name einer Variable setzt sich zusammen aus dem ursprünglichen Namen und der laufenden Nummer der erfolgreichen Unifikation, beginnend bei eins.

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/visualisation/03_root_success.png}
}
\captionof{figure}{Eine erfolgreiche Unifikation mit Einfügung der Teilziele}
\end{minipage}

Die Visualisierung stellt zu unifizierende Ziele als Runde Knoten dar.
Unifikationen werden in  Rechtecken dargestellt, die in zwei weitere Rechtecke aufgeteilt sind.
Dabei enthält jede Unifikation im oberen Rechteck den Regelkopf, mit dem unifiziert werden soll.
Erfolgreiche Unifikationen enthalten im unteren Rechteck die resultierenden Substitutionen.
Außerdem sind sie grün eingefärbt.

War eine Unifikation mit einer Regel erfolgreich, so werden ihre Teilziele als neue Ziele, also runde Knoten, zur Visualisierung hinzugefügt.
Die Substitutionen werden in den Teilzielen angewendet und hervorgehoben.
Die Unifikation und ihre Teilziele werden durch gestrichelte Kanten verbunden.
Dadurch werden in der Visualisierung die Fälle \enquote{Ziel wurde unifiziert mit} und \enquote{Ziel ist Teilziel von Regel} unterschieden.

\subsubsection{Erfolgreiche Unifikation mit Substitution in weiteren Teilzielen}

Im nächsten Schritt steigt der Interpreter in die Teilziele ab und versucht, von links nach rechts diese zu unifizieren.

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/visualisation/04_subgoal_father_success.png}
}
\captionof{figure}{Eine erfolgreiche Unifikation Substitution im nächsten Teilziel}
\end{minipage}

In diesem Beispiel hat der gefundene Fakt keine Teilziele.
Trotzdem müssen die Substitutionen in der restlichen Teilzielen angewendet werden.
Die angewendeten Substitutionen werden dabei in den betreffenden Zielen hervorgehoben.

\subsubsection{Backtracking}

Hier wurden einige Schritte übersprungen.
Das zweite Teilziel wurde mit der ersten Definition von \texttt{parent(X, Y)} unifiziert.
Diese hat als Teilziel \texttt{mother(X, Y)}.
Mit der Belegung \texttt{X = homer} gibt es dafür aber keine Lösung.
Der Interpreter muss also nach einer alternativen Definition von \texttt{parent} suchen und dazu zurückspringen (\enquote{Backtracking}).

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/visualisation/09_mother_backtrack.png}
}
\captionof{figure}{Backtrack nachdem ein Ziel nicht erfüllbar ist}
\end{minipage}

Ein Backtrack wird durch eine aus Punkten bestehende, rot eingefärbte Kante dargestellt.
Das nicht erfüllbare Teilziel wird ebenfalls rot eingefärbt und mit dem Text \enquote{Nicht erfüllbar!} ergänzt.

\subsubsection{Fehlgeschlagene Unifikation}

Nach dem Backtrack findet der Interpreter die zweite \texttt{parent(X, Y)}-Regel, die das Teilziel \texttt{father(X, Y)} hat.
Mit den bisherigen Lösungen ist das neue Ziel \texttt{father(homer, Y)}.
Der Interpreter versucht, mit \texttt{father(abe, homer)} zu unifizieren, da der Funktorname übereinstimmt.
Diese Unifikation schlägt fehl.

\begin{minipage}{\linewidth}
\makebox[\linewidth]{
\includegraphics[width=\linewidth]{build/visualisation/11_subgoal_father_fail.png}
}
\captionof{figure}{Eine fehlgeschlagene Unifikation}
\end{minipage}

Fehlgeschlagene Unifikationen enthalten im unteren Rechteck den Satz \enquote{Unifikation fehlgeschlagen:} und den Grund des Fehlschlags.
Außerdem sind sie rot eingefärbt.

\section{Glossar}

\subsection{Allgemein}

\textbf{Format}:
Das Format beschreibt die Struktur von Prolog-Quelltext im Editor durch Leerzeichen und Umbrüche. Jede Regel wird in ihre eigene Zeile gelegt. Hat eine Regel mehrere Teilziele, so wird die Regelzeile nach dem \enquote{\texttt{:-}}-Operator umgebrochen und alle Teilziele werden in eigene Zeilen gelegt, welche mit zwei Leerzeichen eingerückt sind. Bereits gesetzte Leerzeilen werden beibehalten. Fehlende Leerzeichen vor und hinter dem \enquote{\texttt{:-}}-Operator sowie nach Kommata in Parameterlisten werden eingefügt.

\textbf{Programm}:
Das vorgestellte VIPER-Programm. Dies ist zu unterscheiden von Prolog-Programmen.

\textbf{Prolog-Programm}:
Prolog-Quelltext in Form von Dateien auf einem Speichermedium. Dies ist zu unterscheiden von dem Programm im Sinne des VIPER-Programms.

\textbf{Prolog-Teilmenge}:
Unterstützt werden Identifier, Variablen, nicht-negative ganze Zahlen inklusive der 0, Terme, Regeln, Ziele und Listen.

\subsection{Prolog-interne Begriffe}
\textbf{Abfrage}:
Ziel, für das alle möglichen Lösungen gefunden werden sollen. Die Lösung kann eine Menge an Belegungen für Variablen oder eine Ja-Nein-Antwort sein.

\textbf{Arithmetik}:
Die unterstützte Arithmetik erkennt natürliche Zahlen inklusive der 0. Unterstützte Operationen sind Addition, Subtraktion und Multiplikation (\texttt{+, -, *}) sowie grundlegende Vergleichsoperationen (\texttt{<, =<, >, >=}) inklusive Ungleichheit (\texttt{=\textbackslash=}) und arithmetische Gleichheit (\texttt{=:=}).\\\\Für Abfragen wie \enquote{$4 = 1 + 3$} wird der \texttt{is}-Operator unterstützt. Dieser evaluiert zuerst die rechte Seite arithmetisch und unifiziert diese anschließend mit der Linken.

\textbf{Backtracking}:
%TODO GUI Beheben
Ist für ein Ziel keine Unifikation mehr möglich, muss der Interpreter versuchen, vorhergehende Teilziele anders zu unifizieren oder, falls es keine vorhergehenden Teilziele gibt, eine andere Unifikation für die übergeordnete Regel zu finden.
Diesen Prozess nennt man \enquote{Backtracking}.

\textbf{Cut}:
Ein Cut, in Prolog-Programmen geschrieben als \texttt{!}, ist ein spezielles Ziel.
Die erste Unifikation eines Cuts ist immer erfolgreich.
Wird ein Cut im Kontext einer Abfrage im Zuge des Backtrackings erneut besucht, schlägt die Regel und ihre anderen Definitionen fehl.

\textbf{Fakt}:
Aussage, welche als wahr angenommen wird. Im Kontext von Prolog: eine Regel ohne Teilziele.

\textbf{Funktor}:
Term, der beliebig viele Teil-Terme besitzt.\\Form:\ \texttt{Identifier | Identifier ( Term\{, Term\}*)}

\textbf{Gleichheit}:
Terme sind genau dann gleich, wenn die linke und rechte Seite eines Terms komplett identisch sind und keine Variablen enthalten.

\textbf{Identifier}:
Grundbaustein.\\Form:\ \texttt{[a-z][a-zA-Z0-9]*}

\textbf{Interpreter}:
Ausführungsmechanismus für Abfragen. Nachdem sowohl das zugrunde liegende Prolog-Programm als auch die Abfrage durch den Parser verarbeitet wurden, findet eine schrittweise Interpretation der genannten Abfrage statt.

\textbf{Listen}:
Die leere Liste wird durch \enquote{\texttt{[]}} dargestellt. Eine Liste mit Inhalt wird bspw. in der Form \enquote{\texttt{[1, 2, 3]}} dargestellt und intern als Listenkopf und \enquote{Restliste} behandelt.\\Das heißt:\ \texttt{[1, 2, 3]} = \texttt{[1 | [2 | [3 | []]]]}

\textbf{Parser}:
Umwandlungsmechanismus für Prolog-Programme, der diese in ein für die Weiterverarbeitung geeignetes Format bringt und auf syntaktische Fehler prüft.

\textbf{Regel}:
Vorgeschriebene Folgerungen. So kann man z.B. festlegen, dass man nur der Großvater einer Person ist, wenn man der Vater eines Elternteils der Person ist.\\Form:\ \texttt{Funktor. | Funktor :- Ziel\{, Ziel\}*.}

\textbf{Schritt}:
Nächste Operation, die zur Interpretation einer Abfrage nötig ist.

\textbf{Standardbibliothek}:
Vorgegebene Fakten und Regeln, welche automatisch beim Parsen angefügt werden können. Enthält unter anderem die Regeln \texttt{length} und \texttt{append} für Listen.

\textbf{Substitution}
Ersetzung einer Variable durch einen Term.

\textbf{Term}:
Grundbaustein eines Prolog-Programms.\\Form:\  \texttt{Functor | Variable | Zahl}

\textbf{Unifikation}:
Zwei Terme sind genau dann unifizierbar, wenn sie gleich sind oder Substitutionen gefunden werden können, sodass die Terme gleich sind. Diese Substitutionen sind das Ergebnis der Unifikation.

\textbf{Variable}:
Platzhalter. Erlaubt das allgemeine Beschreiben von Regeln. Können für einen beliebigen Term stehen.\\Form:\  \texttt{[A-Z][a-zA-Z0-9]*}

\textbf{Ziel}:
Zu lösender Teil einer Regel, welcher einem Funktor, einem Unifikationsziel, Arithmetik oder dem \enquote{Cut}-Operator entsprechen kann.\\Form:\ \texttt{Funktor | Term = Term | Term is Term | !}

\textbf{Zustand}:
Ergebnis der bisher durchgeführten Schritte.

\textbf{Zustandsunterschied}:
Schritte zwischen zwei Zuständen.

\subsection{Begriffe der Bedienoberfläche}
\textbf{Dialog}:
Fenster zur Meldung einer Nachricht (Warnungs- oder Fehler-Dialog) oder Abfrage (bspw. Bestätigungs-Dialog).

\textbf{Editor}:
Element der grafischen Oberfläche, welches Eingabe und Bearbeitung von angezeigtem Text ermöglicht.

\textbf{Eingabefeld}:
Element der grafischen Oberfläche. Das Eingabefeld dient zur Eingabe von Abfragen. Es ist nur dann freigegeben, wenn ein korrektes Prolog-Programm eingegeben und geparst wurde.

\textbf{Export}:
Schreiben von Bild-Dateien oder LaTeX-Quellcode in ein Zielverzeichnis auf einem verbundenen Speichermedium. Das Schreiben von Prolog-Programmen auf ein Speichermedium wird nicht als Export, sondern als Speichern bezeichnet.

\textbf{Formatierung}:
Vorgegebener Stil bzgl. der Setzung von Leerzeichen und Umbrüchen. Zu unterscheiden von Syntax, da Formatierung keinen Einfluss auf die Validität des Programms hat.

\textbf{Graph}:
Struktur bestehend aus Knoten und Kanten.

\textbf{GUI / GUI-Element}:
Die GUI entspricht der grafischen Benutzeroberfläche (graphical user interface). Das GUI ist zusammengesetzt aus diversen GUI-Elementen innerhalb eines Fensters (bspw. dem Editor).

\textbf{Konsole}:
Element der grafischen Oberfläche. Die Konsole ist nur lesbar und dient der Ausgabe von Lösungen einer Abfrage sowie anderen Meldungen. 

\textbf{Menüleiste}:
Element der grafischen Oberfläche. Bietet über Text-Menüs Zugriff auf Funktionen wie Speichern und Öffnen.

\textbf{Öffnen}:
Lesen eines ausgewählten Prolog-Programms von einem verbundenen Speichermedium in das Programm. Dies entspricht der Übertragung des Textes aus der gewählten Datei in den Editor.

\textbf{Speichern}:
Schreiben einer Prolog-Programmdatei in ein Zielverzeichnis auf einem verbundenen Speichermedium. Es werden ausschließlich Prolog-Programme gespeichert, andere Schreibvorgänge auf Speichermedien fallen unter den Begriff Export.

\textbf{Visualisierung}:
Navigierbarer Graph, welcher den Ablauf der Interpretation einer Abfrage im Kontext eines gegebenen Prolog-Programms aufzeigt.

\textbf{Zoom}:
Vergrößerung oder Verkleinerung der Visualisierung.

\newpage
\section{Anhang}

\subsection{Unformatiertes simpsons.pl Beispielprogramm}

\begin{lstlisting}
father(abe, homer). father(homer, bart).
father(homer, lisa). mother(marge, bart).

grandfather(X, Y) :-
father(X, Z), parent(Z, Y).

parent(X, Y) :- mother(X, Y).

parent(X, Y) :- father(X, Y).
\end{lstlisting}

\subsection{Formatiertes \texttt{simpsons.pl} Beispielprogramm}

\begin{lstlisting}
father(abe, homer).
father(homer, bart).
father(homer, lisa).
mother(marge, bart).

grandfather(X, Y) :-
  father(X, Z),
  parent(Z, Y).

parent(X, Y) :-
  mother(X, Y).

parent(X, Y) :-
  father(X, Y).
\end{lstlisting}

\end{document}
